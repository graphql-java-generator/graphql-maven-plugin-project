<!DOCTYPE html>
<!--
 | Generated by Apache Maven Doxia Site Renderer 1.9.2 from src\site\apt/client.apt.vm at 2020-10-10

 | Rendered using Apache Maven Default Skin
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="generator" content="Apache Maven Doxia Site Renderer 1.9.2" />
    <title>GraphQL Java Generator - Maven Plugin &#x2013; GraphQL Maven and Gradle Plugin (client mode)</title>
    <link rel="stylesheet" href="./css/maven-base.css" />
    <link rel="stylesheet" href="./css/maven-theme.css" />
    <link rel="stylesheet" href="./css/site.css" />
    <link rel="stylesheet" href="./css/print.css" media="print" />
  </head>
  <body class="composite">
    <div id="banner">
<div id="bannerLeft">com.graphql-java-generator:graphql-maven-plugin-project
</div>
      <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="breadcrumbs">
      <div class="xleft">
        <span id="projectVersion">Version: 1.10</span>
      </div>
      <div class="xright"><a href="project.html" title="Project on Github">Project on Github</a>        &#xA0;| <span id="publishDate">Last Published: 2020-10-10</span>
      </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="leftColumn">
      <div id="navcolumn">
       <h5>Plugin Usage</h5>
    <ul>
     <li class="none"><a href="README.html" title="Introduction">Introduction</a></li>
     <li class="none"><a href="change_log.html" title="Change Log">Change Log</a></li>
     <li class="none"><a href="customscalars.html" title="Custom Scalars">Custom Scalars</a></li>
     <li class="none"><a href="customtemplates.html" title="Custom Code Templates">Custom Code Templates</a></li>
    </ul>
       <h5>Client mode</h5>
    <ul>
     <li class="none"><strong>Client usage</strong></li>
     <li class="none"><a href="client_subscription.html" title="Subscription">Subscription</a></li>
     <li class="none"><a href="introspection.html" title="Introspection">Introspection</a></li>
     <li class="none"><a href="runtimeclasses.html" title="Runtime Classes">Runtime Classes</a></li>
     <li class="none"><a href="client_tutorial.html" title="Client Tutorial">Client Tutorial</a></li>
    </ul>
       <h5>Server mode</h5>
    <ul>
     <li class="none"><a href="server.html" title="Server usage">Server usage</a></li>
     <li class="none"><a href="server_subscription.html" title="Subscription">Subscription</a></li>
     <li class="none"><a href="schema_personalization.html" title="Howto personalize the generated code">Howto personalize the generated code</a></li>
     <li class="none"><a href="server_tutorial.html" title="Server Tutorial">Server Tutorial</a></li>
    </ul>
       <h5>Project internal</h5>
    <ul>
     <li class="none"><a href="howto_build.html" title="How to build?">How to build?</a></li>
     <li class="none"><a href="howto_contribute.html" title="How to contribute?">How to contribute?</a></li>
     <li class="none"><a href="howto_pgp_key.html" title="How to create a PGP key?">How to create a PGP key?</a></li>
     <li class="none"><a href="howto_publish_site.html" title="How to publish the site?">How to publish the site?</a></li>
    </ul>
       <h5>Modules</h5>
    <ul>
     <li class="none"><a href="graphql-java-runtime/index.html" title="graphql-java-runtime">graphql-java-runtime</a></li>
     <li class="none"><a href="graphql-maven-plugin/index.html" title="graphql-maven-plugin">graphql-maven-plugin</a></li>
     <li class="none"><a href="graphql-java-client-dependencies/index.html" title="graphql-java-client-dependencies">graphql-java-client-dependencies</a></li>
     <li class="none"><a href="graphql-java-server-dependencies/index.html" title="graphql-java-server-dependencies">graphql-java-server-dependencies</a></li>
     <li class="none"><a href="graphql-maven-plugin-logic/index.html" title="graphql-maven-plugin-logic">graphql-maven-plugin-logic</a></li>
     <li class="none"><a href="graphql-maven-plugin-samples/index.html" title="graphql-maven-plugin-samples">graphql-maven-plugin-samples</a></li>
    </ul>
       <h5>Project Documentation</h5>
    <ul>
     <li class="collapsed"><a href="project-info.html" title="Project Information">Project Information</a></li>
    </ul>
      <a href="https://maven.apache.org/" title="Maven" class="poweredBy">
        <img class="poweredBy"  alt="Maven" src="https://maven.apache.org/images/logos/maven-feather.png"     />
      </a>
      </div>
    </div>
    <div id="bodyColumn">
      <div id="contentBox">
<section>
<h2><a name="Client_mode_usage_description"></a>Client mode usage description</h2>
<ul>
<li><a href="#Client_mode_usage_description">Client mode usage description</a>
<ul>
<li><a href="#Summary">Summary</a></li>
<li><a href="#How_does_it_work.3F">How does it work?</a></li>
<li><a href="#How_to_use_the_plugin.3F">How to use the plugin?</a></li>
<li><a href="#Full_requests_versus_Partial_requests">Full requests versus Partial requests</a>
<ul>
<li><a href="#Full_requests">Full requests</a></li>
<li><a href="#Partial_requests">Partial requests</a></li></ul></li>
<li><a href="#Use_direct_queries">Use direct queries</a></li>
<li><a href="#How_to_personalize_the_plugin_behavior.3F">How to personalize the plugin behavior?</a>
<ul>
<li><a href="#Use_a_preconfigured_Jersey_client">Use a preconfigured Jersey client</a></li>
<li><a href="#Use_your_own_code_templates">Use your own code templates</a></li></ul></li></ul></li></ul><section>
<h3><a name="Summary">Summary</a></h3>
<p>The client mode makes it easy for a Java GraphQL client-side application, to execute queries/mutations/subscriptions against a GraphQL server. The graphql-maven-plugin generates all the necessary code, so that a Java application can call a GraphQL server by simply calling the relevant Java method.</p>
<p>The plugin manages two kinds of request:</p>
<ul>
<li>The <b>Full request</b>: it's actually a standard GraphQL request, that you can test within graphiql</li>
<li>The <b>Partial request</b>: you can call a java method that executes one of the queries/mutations/subscriptions defined in the schema. This java method accepts one parameter, for each parameter of this query/mutation/subscription.</li></ul>
<p>It manages two ways of executing the request:</p>
<ul>
<li>The <b>direct execution</b>: you call the generated method with the GraphQL request (partial or full), and you receive the result into Java objects. This is simpler, but slower: for technical reasons, the plugin has two analyze the content of the request. And it will do that at each execution. The main reason for that is to allow proper deserialization of GraphQL interfaces and unions: the __typename is injected into the query, for all returned object, union and interface types.</li>
<li>The recommended <b>prepared execution</b>: 
<ul>
<li>A GraphQLRequest object is created by the application, if possible at application startup. This allows to analyze the request only once. And it avoids errors during the app execution, as all the GraphQL requests have been checked at startup.</li>
<li>Each GraphQL request execution is executed from this object. </li>
<li><i>Note: the GraphQLRequest object has been created in the 1.6 release. The prepared object was before stored into a ObjectResponse. This ObjectResponse has been maintained when used with the withQueryResponseDef Builder method, and the code that uses will continue to work. Support for other Builder method has been removed.</i>
<ul>
<li><i>There is no plan yet to remove the ObjectResponse object and the withQueryResponseDef Builder method. But they should be avoided in new code.</i></li></ul></li></ul></li></ul>
<p>Both kinds of requests, and both modes of execution allows to use bind parameters into your query definitions. </p></section><section>
<h3><a name="How_does_it_work.3F"></a><a name="How_does_it_work">How does it work?</a></h3>
<p>When configuring the graphql-maven-plugin in client mode, it reads a GraphQL schema file, and generates all the necessary code to make it easy to call a GraphQL server. </p>
<p>As an overview, it generates:</p>
<ul>
<li>One java class for each Query/Mutation/Subscription object. This object contains all the method allowing to execute a full query, and shortcuts methods to execute each of the queries defined in the query/mutation/subscription.
<ul>
<li>The introspection queries (__schema and __type) are added to the query defined in the GraphQL schema. If no query exists in the schema, a default one is created, named QueryType.</li></ul></li>
<li>One POJO for each standard object of the GraphQL object</li>
<li>One GraphQLRequest object</li>
<li>All the necessary runtime is actually attached as source code into your project: the generated code is stand-alone.
<ul>
<li>So, your project, when it runs, doesn't depend on any external dependency from graphql-java-generator.
<ul>
<li><b>This is why we call it an accelerator</b>: you can generate the code once, and get rid of graphql-java-generator if you wish. BTW: we think its better to continue using it! But you're free to leave, and keep the generated code. :)</li>
<li>You can change this default behavior, and use the runtime into an external dependency. Read the <a href="./schema_personalization.html">Howto personalize the generated code</a> for more information.</li></ul></li></ul></li></ul></section><section>
<h3><a name="How_to_use_the_plugin.3F"></a><a name="How_to_use_the_plugin">How to use the plugin?</a></h3>
<p>First, you'll have to create or get your GraphQL schema. The GraphQL plugin expects a <i>.graphqls</i> file. See the <a class="externalLink" href="https://graphql.org/learn/schema/">GraphQL schema doc</a> for all the details.</p>
<p>Then, add the plugin to your Maven POM file:</p>
<div class="source">
<pre>&lt;project ...&gt;
...

        &lt;build&gt;
                &lt;plugins&gt;
...
                        &lt;plugin&gt;
                                &lt;groupId&gt;com.graphql-java-generator&lt;/groupId&gt;
                                &lt;artifactId&gt;graphql-maven-plugin&lt;/artifactId&gt;
                                &lt;version&gt;1.10&lt;/version&gt;
                                &lt;executions&gt;
                                        &lt;execution&gt;
                                                &lt;goals&gt;
                                                        &lt;goal&gt;graphql&lt;/goal&gt;
                                                &lt;/goals&gt;
                                        &lt;/execution&gt;
                                &lt;/executions&gt;
                                &lt;configuration&gt;
                                        &lt;mode&gt;client&lt;/mode&gt;
                                        &lt;packageName&gt;my.target.package&lt;/packageName&gt;
                                &lt;/configuration&gt;
                        &lt;/plugin&gt;
...
                        &lt;extensions&gt;
                                &lt;!-- Adding these extensions prevents the error below, with JDK 9 and higher: --&gt;
                                &lt;!-- NoSuchMethodError: 'java.lang.String javax.annotation.Resource.lookup()' --&gt;
                                &lt;extension&gt;
                                        &lt;groupId&gt;javax.annotation&lt;/groupId&gt;
                                        &lt;artifactId&gt;javax.annotation-api&lt;/artifactId&gt;
                                        &lt;version&gt;1.3.2&lt;/version&gt;
                                &lt;/extension&gt;
                                &lt;extension&gt;
                                        &lt;groupId&gt;javax.annotation&lt;/groupId&gt;
                                        &lt;artifactId&gt;jsr250-api&lt;/artifactId&gt;
                                        &lt;version&gt;1.0&lt;/version&gt;
                                &lt;/extension&gt;
                        &lt;/extensions&gt;
        
                &lt;/plugins&gt;
        &lt;/build&gt;
...
&lt;/project&gt;
</pre></div>
<p>The mode is optional, here, as client is the default one. Valid values are: <i>client</i> and <i>server</i>.</p>
<p>You can define the package that will contain the generated code. If you don't, the default package is <i>com.generated.graphql</i>. This package contains the generated code. </p>
<p>The necessary runtime code source is joined into the generated code, and remains in its original package, which is <i>com.graphql_java_generator.*</i>. So everything is embedded. Read the <a href="./schema_personalization.html">Howto personalize the generated code</a> if you want to change this default behavior.</p></section><section>
<h3><a name="Full_requests_versus_Partial_requests">Full requests versus Partial requests</a></h3>
<p>When the plugin generates the query/mutation/subscription java classes (one for each), it generates two families of methods: Full requests, and Partial requests, as introduced on the top of this page.</p>
<p>In either case, you can call query and mutation in the exact same way. You'll only find queries, in the samples below. But mutations work the same.</p><section>
<h4><a name="Full_requests">Full requests</a></h4>
<p>Full requests are only valid for queries and mutations. Subscriptions work only with Partial Request. See the <a href="./client_subscription.html">Client Subscription page</a>.</p>
<p>For each query/mutation/subscription in the GraphQL schema, a Java class is generated.</p>
<p>The <i>exec</i> and <i>execWithBindValues</i> methods allows you to execute full GraphQL queries, that is: the full GraphQL request, as it would work in the graphiql interface. So you can test your request in graphiql, then parse the tested request into you code, as a Full Request (see below for sample).</p>
<p>This is interesting when:</p>
<ul>
<li>You want to execute several queries into one call toward the server</li>
<li>You want to add directives to the query/mutation itself</li>
<li>You want to use GraphQL global fragments into your query (by global, we mean not inline fragment)</li></ul>
<p>You'll find samples in the sample projects, in the test part of the client samples.</p>
<p>To use full request, you need to (sample follows):</p>
<ul>
<li>Configure the <i>GraphQLRequest</i>
<ul>
<li>To do this, you must create a <i>GraphQLConfiguration</i>. This configuration is essentially defining the GraphQL endpoint</li>
<li>If you have only one GraphQL server, you can use the default <i>GraphQLRequest</i>, by calling its static <i>setStaticConfiguration(GraphQLConfiguration)</i> method</li>
<li>If you work with more than one GraphQL server, you can use the <i>setStaticConfiguration(GraphQLConfiguration)</i> to set a default configuration, and call the <i>setInstanceConfiguration(GraphQLConfiguration)</i> method for instance of <i>GraphQLRequest</i> that would call another server.</li></ul></li>
<li>Create on <i>GraphQLRequest</i> with your GraphQL query</li>
<li>Then execute one or several time the query, possibly with different bind parameter values.</li>
<li>Retrieves from the query/mutation response, the field the contains the structure for the query(ies)/mutation(s) you called. All the server response is stored in POJOs that have been generated from the GraphQL schema, including object types, input types, enums, interfaces, unions (as Java interfaces)...</li></ul>
<p>To execute the request, you must use the <i>execQuery</i>/<i>execMutation</i> method of your <i>GraphQLRequest</i> instance, to get the proper response. This response is the query/mutation response type. So, to get the real result from the server, you must call the getter that is link to your request, <i>getBoards()</i> in the above sample.</p>
<div class="source">
<pre>GraphQLRequest request;

void setup() {
                // If you have one GraphQL endpoint, use the static configuration.
                // The classname of the Query or Mutation is the type name, as defined in the GraphQL schema
                GraphQLRequest.setStaticConfiguration(new GraphQLConfiguration(Main.GRAPHQL_ENDPOINT_URL));
                
                // Create the GraphQL request
                request = new GraphQLRequest(&quot;&quot; //
                                + &quot;fragment topic on Topic {title posts(since: &amp;sinceParam, memberId: ?memberIdParam, memberName: \&quot;?\&quot;){id} author{id}}\r&quot;
                                + &quot;query{boards{id name topics {id ...topic}}}&quot;);
}

void exec(Date since) {
        // This sample :
        // - gives a value for the mandatory (as it starts with &amp;) sinceParam bind parameter,
        // - gives no value for the optional (as it starts with ?) memberIdParam bind parameter.
        // So only the since input parameter will be sent to the server. 
        List&lt;Board&gt; boards = request.execQuery(&quot;sinceParam&quot;, since).getBoards();

        // Do something with boards
        ...
}
</pre></div>
<p>In the GraphQL query, you can use:</p>
<ul>
<li>Fragments (inline or not)</li>
<li>Directives</li>
<li>Union, or interface types</li>
<li>input parameters for query/mutation and field input parameters, or in directives arguments. The given value for these input parameters may be:
<ul>
<li>Hard coded value in your GraphQL query. That is: the literal value for the input parameter, like for the <i>memberName</i> parameter in the above sample.</li>
<li>An optional bind parameter, if it's a valid identifier, prefixed with ?, like the <i>memberIdParam</i> parameter, here above. In this case, if you don't provide a value for this parameter at execution time, the parameter is not sent to the server. Of course, if this parameter is mandatory in your GraphQL schema, you'll get an error from the GraphQL server.</li>
<li>A mandatory bind parameter, if it's a valid identifier, prefixed with &amp;, like the <i>sinceParam</i> parameter, here above. In this case, if you don't provide a value for this parameter at execution time, the plugin throws a <i>GraphQLRequestExecutionException</i> at execution time, as it expects a value for this parameter. A mandatory parameter in your query may be an optional one in the GraphQL schema: it's up to your use case to define if this parameter is mandatory or not.</li></ul></li></ul>
<p>Please note that the bind parameters can be provided as a map, where the key is the parameter name, by using the <i>xxxWithBindValues(GraphQLRequest, [xxx], Map)</i>, where [xxx] is the list of values for the query/mutation.</p>
<p>The previous sample then becomes:</p>
<div class="source">
<pre>GraphQLRequest request;

void setup() {
                // If you have one GraphQL endpoint, use the static configuration.
                // The classname of the Query or Mutation is the type name, as defined in the GraphQL schema            
                GraphQLRequest.setStaticConfiguration(new GraphQLConfiguration(Main.GRAPHQL_ENDPOINT_URL));
                
                // Create the GraphQL request
                request = new GraphQLRequest(&quot;&quot; //
                                + &quot;fragment topic on Topic {title posts(since: &amp;sinceParam, memberId: ?memberIdParam, memberName: \&quot;?\&quot;){id} author{id}}\r&quot;
                                + &quot;query{boards{id name topics {id ...topic}}}&quot;);
}

void exec(Date since, String memberName, String memberId) {
        Map&lt;String, Object&gt; params = new HashMap&lt;&gt;();
        params.put(&quot;sinceParam&quot;, since);
        params.put(&quot;memberName&quot;, memberName);
        params.put(&quot;memberId&quot;, memberId);
        
        // This sample :
        // - gives a value for the mandatory (as it starts with &amp;) sinceParam bind parameter,
        // - gives no value for the optional (as it starts with ?) memberIdParam bind parameter.
        // So only the since input parameter will be sent to the server. 
        List&lt;Board&gt; boards = request.execQuery(params).getBoards();

        // Do something with boards
        ...
}
</pre></div></section><section>
<h4><a name="Partial_requests">Partial requests</a></h4>
<p>For each query/mutation/subscription class, the plugin also generates XxxxEXecutor classes, where Xxxx is the query/mutation/subscription GraphQL type name. These classes contain <i>Yyyy</i> and <i>YyyyWithBindValues</i> methods, where <i>Yyyy</i> is successively each query/mutation/subscription defined in this query/mutation/subscription object.</p>
<p>As subscriptions work differently, they are documented in the <a href="./client_subscription.html">Client Subscription page</a>. </p>
<p>These methods are easier to use as:</p>
<ul>
<li>The query/mutation/subscription parameters (as defined in the GraphQL schema) become parameters of the relevant generated java methods. So you don't need to define and map bind parameters for them.
<ul>
<li>But you can still use bind parameters for input parameters of the fields you request, of course</li></ul></li>
<li>The methods return directly the response for the query/mutation/subscription: you don't need to call a getter to retrieve it. The returned data is stored in the POJOs that have been generated from the GraphQL schema. This includes the object types, input types, enums, interfaces, unions (as Java interfaces)...</li></ul>
<p>Below is a sample of the client code:</p>
<div class="source">
<pre>QueryTypeExecutor queryExecutor;
GraphQLRequest topicsRequest;

void setup() {
                // Instanciate a Query executor, with the relevant GraphQL endpoint
                queryExecutor = new QueryTypeExecutor(&quot;https://your.server/graphql&quot;);
                                
                // Create the GraphQL request
                // This prepares a GraphQ Request that will execute: topics{id date author{name email alias id type} nbPosts}
                topicsRequest = queryExecutor.getTopicsGraphQLRequest(&quot;{id date author{name email alias id type} nbPosts}&quot;);
}

void exec() {
        // The topic query accepts one parameter. If you don't want to provide it, you can give it the null value
        List&lt;Topic&gt; topics = queryExecutor.topics(topicsRequest, &quot;a board name&quot;);

        // Do something with topics
        ...
}
</pre></div>
<p>This method needs less code, in your application.</p>
<p>Directives can be defined for the requested fields, or their parameters. If you need to define directives at the query/mutation/subscription level, you need to execute a Full Request (see here above).</p>
<p>The bind parameters works as specified for the Full queries.</p>
<p>Of course, you can use input parameters for field or directives.</p>
<p>Below is a sample of a request, with bind parameters:</p>
<div class="source">
<pre>QueryTypeExecutor queryExecutor = new QueryTypeExecutor(&quot;https://your.server/graphql&quot;);
GraphQLRequest topicsRequest;

void setup() {
                // ?memberId is an optional bind parameter, of name &quot;memberId&quot;
                // ?memberName is an optional bind parameter, of name &quot;memberName&quot;
                // ?sinceParam is an optional bind parameter, of name &quot;sinceParam&quot;: you must provide it at execution time, or
                // a GraphQLRequestExecutionException will be thrown.
                topicsRequest = queryExecutor.getTopicsGraphQLRequest(&quot;{id date author{name email alias id type} nbPosts &quot;
                        + &quot;posts(memberId:?memberId, memberName: ?memberName, since: &amp;sinceParam){id date author{name email alias}}}&quot;);
}

void exec(Date since, String memberName, String memberId) {
        // The topic query, as defined in the GraphQL schema, has one parameter: the board name.
        // This parameter is a paremeter of the topics method
        // You can then as many couples (&quot;bindParameterName&quot;, bindParameterValue) that you want, in any order
        List&lt;Topic&gt; topics = queryExecutor.topics(topicsRequest, &quot;a board name&quot;,&quot;sinceParam&quot;, since, &quot;memberName&quot;, memberName, &quot;memberId&quot;, memberId);

        // Do something with topics
        ...
}
</pre></div>
<p>Please note that the bind parameters can be provided as a map, where the key is the parameter name, by using the <i>xxxWithBindValues(GraphQLRequest, [xxx], Map)</i>, where [xxx] is the list of values for the query/mutation/subscription.</p>
<p>The previous sample then becomes:</p>
<div class="source">
<pre>QueryTypeExecutor queryExecutor = new QueryTypeExecutor(&quot;https://your.server/graphql&quot;);
GraphQLRequest topicsRequest;

void setup() {
                topicsRequest = queryExecutor.getTopicsGraphQLRequest(&quot;{id date author{name email alias id type} nbPosts &quot;
                        + &quot;posts(memberId:?memberId, memberName: ?memberName, since: &amp;sinceParam){id date author{name email alias}}}&quot;);
}

void exec(Date since, String memberName, String memberId) {
        Map&lt;String, Object&gt; params = new HashMap&lt;&gt;();
        params.put(&quot;sinceParam&quot;, since);
        params.put(&quot;memberName&quot;, memberName);
        params.put(&quot;memberId&quot;, memberId);
        
        // The topic query, as defined in the GraphQL schema, has one parameter: the board name
        // This parameter is a paremeter of the topics method
        List&lt;Topic&gt; topics = queryExecutor.topicsWithBindValues(topicsRequest, &quot;a board name&quot;, params);

        // Do something with topics
        ...
}
</pre></div></section></section><section>
<h3><a name="Use_direct_queries">Use direct queries</a></h3>
<p>If you don't want to store the <i>GraphQLRequest</i>, you can avoid that, by using direct queries. But please not that there is an overhead, as the query must be analyzed at runtime by the plugin to manage input parameters, and add the <i>__typename</i> GraphQL introspection attribute where it is missing, to insure proper java deserialization of the response.</p>
<p>So using direct queries generates an overhead at each execution, whereas with prepared queries, the request analysis is done only once.</p>
<p>Direct queries are available only for partial queries. The input parameters for fields and directive are provided the same way as for full queries:</p>
<ul>
<li>With a list of couples (&quot;bindParameterName&quot;, bindParameterValue)</li>
<li>Or with a map containing this parameter values, where the key is the bindParameterName, and the value is the bind parameter value.
<p>Here is a sample with the bind parameters value given as method parameters: </p>
<div class="source">
<pre>QueryTypeExecutor queryExecutor = new QueryTypeExecutor(&quot;https://your.server/graphql&quot;);

void exec(Date since, String memberName, String memberId) {
        
        // The topic query accept one parameter.
        // You can then as many couples (&quot;bindParameterName&quot;, bindParameterValue) that you want.
        List&lt;Topic&gt; topics = queryExecutor.topicsWithBindValues(&quot;{id date author{name email alias id type} nbPosts &quot;
                        + &quot;posts(memberId:?memberId, memberName: ?memberName, since: &amp;sinceParam){id date author{name email alias}}}&quot;,
                        // One parameter for this query, in the GraphQL schema 
                        &quot;a board name&quot;, 
                        // Then the parameters name and value: 
                        &quot;sinceParam&quot;, since,
                        &quot;memberName&quot;, memberName,
                        &quot;memberId&quot;, memberId,
                        );

        // Do something with topics
        ...
}
</pre></div>
<p>Here is a sample with the bind parameters value given as a map: </p>
<div class="source">
<pre>QueryTypeExecutor queryExecutor = new QueryTypeExecutor(&quot;https://your.server/graphql&quot;);

void exec(Date since, String memberName, String memberId) {
        Map&lt;String, Object&gt; params = new HashMap&lt;&gt;();
        params.put(&quot;sinceParam&quot;, since);
        params.put(&quot;memberName&quot;, memberName);
        params.put(&quot;memberId&quot;, memberId);
        
        // The topic query accept one parameter.
        // You can then as many couples (&quot;bindParameterName&quot;, bindParameterValue) that you want.
        List&lt;Topic&gt; topics = queryExecutor.topicsWithBindValues(&quot;{id date author{name email alias id type} nbPosts &quot;
                        + &quot;posts(memberId:?memberId, memberName: ?memberName, since: &amp;sinceParam){id date author{name email alias}}}&quot;, 
                        // One parameter for this query, in the GraphQL schema 
                        &quot;a board name&quot;,
                        // The bind values are in this map 
                        params);

        // Do something with topics
        ...
}
</pre></div></li></ul></section><section>
<h3><a name="How_to_personalize_the_plugin_behavior.3F"></a><a name="How_to_personalize_the_plugin_behavior">How to personalize the plugin behavior?</a></h3><section>
<h4><a name="Use_a_preconfigured_Jersey_client">Use a preconfigured Jersey client</a></h4>
<p>You can use a preconfigured Jersey client instance to support customization of the rest request:</p>
<div class="source">
<pre>    public QueryTypeExecutor(String graphqlEndpoint, Client client, ObjectMapper objectMapper)
</pre></div></section><section>
<h4><a name="Use_your_own_code_templates">Use your own code templates</a></h4>
<p>The plugin generates the code, from a Velocity templates. You can override the provided templates.</p>
<p>Please take a look at the <a href="./customtemplates.html">custom templates doc</a> for all the details. </p></section></section></section>
      </div>
    </div>
    <div class="clear">
      <hr/>
    </div>
    <div id="footer">
      <div class="xright">
        Copyright &#169;      2020..      </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
  </body>
</html>
