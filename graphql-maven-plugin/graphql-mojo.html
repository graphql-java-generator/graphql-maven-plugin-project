<!DOCTYPE html>


<!--
 | Generated by Apache Maven Doxia Site Renderer 2.0.0-M7 from org.apache.maven.plugins:maven-plugin-report-plugin:4.0.0-beta-1:report at 2025-09-16
 | Rendered using Apache Maven Fluido Skin 2.0.0-M5
-->
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="generator" content="Apache Maven Doxia Site Renderer 2.0.0-M7" />
    <title>GraphQL Java Generator - Maven Plugin â€“ graphql:graphql</title>
    <link rel="stylesheet" href="./css/apache-maven-fluido-2.0.0-M5.min.css" />
    <link rel="stylesheet" href="./css/site.css" />
    <link rel="stylesheet" href="./css/print.css" media="print" />
    <script src="./js/apache-maven-fluido-2.0.0-M5.min.js"></script>
  </head>
  <body class="topBarDisabled">
    <div class="container-fluid">
      <header>
        <div id="banner">
          <div class="pull-left"></div>
          <div class="pull-right"></div>
          <div class="clear"><hr/></div>
        </div>

        <div id="breadcrumbs">
          <ul class="breadcrumb">
        <li id="projectVersion">Version: 3.0.1</li>
        <li id="publishDate" class="pull-right"><span class="divider">|</span> Last Published: 2025-09-16</li>
        <li class="pull-right"><span class="divider">|</span>
<a href="project.html" title="Project on Github">Project on Github</a></li>
        <li class="pull-right"><a href="../project.html" title="Project on Github">Project on Github</a></li>
          </ul>
        </div>
      </header>
      <div class="row-fluid">
        <header id="leftColumn" class="span2">
          <nav class="well sidebar-nav">
  <ul class="nav nav-list">
   <li class="nav-header">Project Documentation</li>
    <li><a href="project-info.html" title="Project Information"><span class="icon-chevron-right"></span>Project Information</a></li>
    <li><a href="project-reports.html" title="Project Reports"><span class="icon-chevron-right"></span>Project Reports</a></li>
  </ul>
          </nav>
          <div class="well sidebar-nav">
            <div id="poweredBy">
              <div class="clear"></div>
              <div class="clear"></div>
              <div class="clear"></div>
<a href="https://maven.apache.org/" title="Maven" class="builtBy"><img class="builtBy"  alt="Maven" src="https://maven.apache.org/images/logos/maven-feather.png" style="" /></a>
            </div>
          </div>
        </header>
        <main id="bodyColumn"  class="span10" >
<section>
<h1>graphql:graphql</h1><a id="graphql.3Agraphql"></a>
<p><strong>Full name</strong>:</p>
<p>com.graphql-java-generator:graphql-maven-plugin:3.0.1:graphql</p>
<p><strong>Description</strong>:</p>
<p><p><b>This goal is <u>deprecated</u></b>. The <i>graphql</i> goal generates the java code from one or more GraphQL schemas. It allows to work in Java with graphQL, in a schema first approach.</p> It will be maintained in the future 2.x versions. The <i>generateClientCode</i> and <i>generateServerCode</i> should be used instead.
<br />
 The <i>graphql</i> goal has two main modes: 
<ul>
 <li><b>client mode:</b> it does the same jobs as the <i>generateClientCode</i> goal. It generates a class for each query, mutation and subscription type. These classes contain the methods to call the queries, mutations and subscriptions. That is: to execute a query against the GraphQL server, you just have to call one of this method. It also generates the POJOs from the GraphQL schema. The <b>GraphQL response is stored in these POJOs</b>, for an easy and standard use in Java.</li>
 <li><b>server mode:</b> it does the same jobs as the <i>generateServerCode</i> goal. It generates the whole heart of the GraphQL server. The developer has only to develop request to the data. That is the main method (in a jar project) or the main server (in a war project), and all the Spring wiring, based on graphql-java-spring, itself being build on top of graphql-java. It also generates the POJOs. An option allows to annotate them with the standard JPA annotations, to make it easy to link with a database. This goal generates the interfaces for the DataFetchersDelegate (often named providers) that the server needs to implement</li>
</ul></p>
<p><strong>Attributes</strong>:</p>
<ul>
<li>Requires a Maven project to be executed.</li>
<li>The goal is thread-safe and supports parallel builds.</li>
<li>Binds by default to the <a class="externalLink" href="https://maven.apache.org/ref/current/maven-core/lifecycles.html">lifecycle phase</a>: <code>generate-sources</code>.</li></ul><section>
<h2>Optional Parameters</h2><a id="Optional_Parameters"></a>
<table class="table table-striped">
<tr class="a">
<th>Name</th>
<th>Type</th>
<th>Since</th>
<th>Description</th></tr>
<tr class="b">
<td style="text-align: left;"><a href="#addRelayConnections"><code>&lt;addRelayConnections&gt;</code></a></td>
<td><code>boolean</code></td>
<td><code>-</code></td>
<td><p>True if the plugin is configured to add the Relay connection capabilities to the field marked by the <i>@RelayConnection</i> directive.</p>
<p>If so, the plugin reads the provided GraphQL schema file(s), and enriches them with the interfaces and types needed to respect the Relay Connection specification. The entry point for that is the <i>@RelayConnection</i> directive.</p>
<p>You'll find all the information on the plugin web site. Please check the <a href="https://graphql-maven-plugin-project.graphql-java-generator.com/client_add_relay_connection.html>client
Relay capability page&lt;/A> or the &lt;A
HREF=" https:="" graphql-maven-plugin-project.graphql-java-generator.com="" server_add_relay_connection.html="">server Relay capability page</a>.</p><br /><strong>Default</strong>: <code>false</code><br /><strong>User Property</strong>: <code>com.graphql_java_generator.mavenplugin.addRelayConnections</code></td></tr>
<tr class="a">
<td style="text-align: left;"><a href="#batchMappingDataFetcherReturnType"><code>&lt;batchMappingDataFetcherReturnType&gt;</code></a></td>
<td><code>BatchMappingDataFetcherReturnType</code></td>
<td><code>-</code></td>
<td><p>This parameter is used only when generateBatchMappingDataFetchers is set to <i>true</i>. It determines the return type of the data fetchers, as defined in the <a href="https://docs.spring.io/spring-graphql/reference/controllers.html#controllers.batch-mapping.return.values">spring-graphql documentation</a>.</p>
<p>The allowed values are (where K is the key type, that is: the parent object, and V is the value to be loaded in batch):</p><row>
</row><row>
</row><row>
</row><row>
</row><row>
</row>
<table>
 <tbody>
  <tr>
   <th>Value</th>
   <th>Return type</th>
   <td>MONO_MAP</td>Mono&lt;Map&lt;K,V&gt;&gt;
   <td>MAP</td>
   <td>Map&lt;K,V&gt;</td>
   <td>FLUX&gt;</td>
   <td>Flux&lt;V&gt;</td>
   <td>COLLECTION</td>
   <td>Collection&lt;V&gt;</td>
  </tr>
 </tbody>
</table>
<p>The default value is <code>Flux&lt;V&gt;</code></p>
<p>For an easier use of this parameter, the comment of the generated data fetchers details the exact expected type.</p><br /><strong>Default</strong>: <code>FLUX</code><br /><strong>User Property</strong>: <code>com.graphql_java_generator.mavenplugin.batchMappingDataFetcherReturnType</code></td></tr>
<tr class="b">
<td style="text-align: left;"><a href="#copyRuntimeSources"><code>&lt;copyRuntimeSources&gt;</code></a></td>
<td><code>boolean</code></td>
<td><code>-</code></td>
<td><p>Flag to enable (or not) the copy of the sources from the graphql-java-runtime library to target source code directory. That is: it allows to control whether the runtime code is embedded in the generated code or not.</p>
<p><b>Caution:</b> the default value changed since the 2.0 version. In 1.x version, the default value is true. Since 2.0 version, the default value is false.</p>
<ul>
 <li>If copyRuntimeSources=true: the runtime is copied along with the generated code. The project configuration (pom.xml or build.gradle) must contain the <code>com.graphql-java-generator:graphql-java-dependencies</code> dependency, with the same version as the GraphQL plugin</li>
 <li>If copyRuntimeSources=false: the runtime is NOT copied along with the generated code. The project configuration (pom.xml or build.gradle) must contain the <code>com.graphql-java-generator:graphql-java-runtime</code> dependency, with the same version as the GraphQL plugin</li>
 <li></li>
</ul><br /><strong>Default</strong>: <code>false</code><br /><strong>User Property</strong>: <code>com.graphql_java_generator.mavenplugin.copyRuntimeSources</code></td></tr>
<tr class="a">
<td style="text-align: left;"><a href="#customScalars"><code>&lt;customScalars&gt;</code></a></td>
<td><code>List&lt;CustomScalarDefinition&gt;</code></td>
<td><code>-</code></td>
<td><p>This parameter contains the list of custom scalars implementations. One such implementation must be provided for each custom scalar defined in the GraphQL implemented by the project for its GraphQL schema. It's a list, where the key is the scalar name, as defined in the GraphQL schema, and the value is the full class name of the implementation of <code>graphql.schema.GraphQLScalarType</code><!-- no javadoc sites associated -->.</p>
<p>This parameter is a list of customScalars. For each one, you must define the name, the javaType and exactly one of these fields: graphQLScalarTypeClass, graphQLScalarTypeStaticField or graphQLScalarTypeGetter.</p>
<p>Here is the detail:</p>
<ul>
 <li><b>graphQLTypeName</b>: The type name, as defined in the GraphQL schema, for instance <i>Date</i></li>
 <li><b>javaType</b>: The full class name for the java type that contains the data for this type, once in the Java code, for instance <i>java.util.Date</i></li>
 <li><b>graphQLScalarTypeClass</b>: The full class name for the <code>graphql.schema.GraphQLScalarType</code><!-- no javadoc sites associated --> that will manage this Custom Scalar. This class must be a subtype of <code>graphql.schema.GraphQLScalarType</code><!-- no javadoc sites associated -->. Bu the constructor of <code>graphql.schema.GraphQLScalarType</code><!-- no javadoc sites associated --> has been deprecated, so you'll find no sample for that in this project</li>
 <li><b>graphQLScalarTypeStaticField</b>: The full class name followed by the static field name that contains the <code>graphql.schema.GraphQLScalarType</code><!-- no javadoc sites associated --> that will manage this Custom Scalar. For instance, the graphql-java package provides several custom scalars like <i>graphql.Scalars.GraphQLLong</i>. You can also use the <i>graphql-java-extended-scalars</i> project, that provides other custom scalars like <i>graphql.scalars.ExtendedScalars.NonNegativeInt</i>.</li>
 <li><b>graphQLScalarTypeGetter</b>: The full class name followed by the static method name that returns the <code>graphql.schema.GraphQLScalarType</code><!-- no javadoc sites associated --> that will manage this Custom Scalar. For instance: <i>org.mycompany.MyScalars.getGraphQLLong()</i> or <i>com.graphql_java_generator.customscalars.GraphQLScalarTypeDate</i>. This call may contain parameters, provided that this a valid java command.</li>
</ul>
<p>Please have a look at the allGraphQLCases (both client and server) samples for more information. The <a href="https://github.com/graphql-java-generator/graphql-maven-plugin-project/blob/master/graphql-maven-plugin-samples/graphql-maven-plugin-samples-allGraphQLCases-client/pom.xml">allGraphQLCases client pom</a> is a good sample.</p><br /><strong>User Property</strong>: <code>com.graphql_java_generator.mavenplugin.customScalars</code></td></tr>
<tr class="b">
<td style="text-align: left;"><a href="#enumPrefix"><code>&lt;enumPrefix&gt;</code></a></td>
<td><code>String</code></td>
<td><code>-</code></td>
<td>An optional prefix to add to the classnames of the generated java classes for GraphQL enums. The prefix is added at the beginning of the java classname, and must be compatible with java naming rules (no space, dot, comma, etc.)<br /><strong>User Property</strong>: <code>com.graphql_java_generator.mavenplugin.enumPrefix</code></td></tr>
<tr class="a">
<td style="text-align: left;"><a href="#enumSuffix"><code>&lt;enumSuffix&gt;</code></a></td>
<td><code>String</code></td>
<td><code>-</code></td>
<td>An optional suffix to add to the classnames of the generated java classes for GraphQL enums. The suffix is added at the end of the java classname, and must be compatible with java naming rules (no space, dot, comma, etc.)<br /><strong>User Property</strong>: <code>com.graphql_java_generator.mavenplugin.enumSuffix</code></td></tr>
<tr class="b">
<td style="text-align: left;"><a href="#generateBatchLoaderEnvironment"><code>&lt;generateBatchLoaderEnvironment&gt;</code></a></td>
<td><code>boolean</code></td>
<td><code>-</code></td>
<td><p>(only for server mode) Indicates if the plugin should generate add the <code>org.dataloader.BatchLoaderEnvironment</code><!-- no javadoc sites associated --> parameter to the <i>batchLoader</i> methods, in DataFetchersDelegate. This parameter allows to get the context of the Batch Loader, including the context associated to the id, when using the id has been added by the <code>org.dataloader.DataLoader.load(java.lang.Object,java.lang.Object)</code><!-- no javadoc sites associated --> method.</p>
<p>For instance, if you have the method below, for a field named <i>oneWithIdSubType</i> in a DataFetcherDelegate:</p>
<pre>
@Override
public CompletableFuture&lt;AllFieldCasesWithIdSubtype&gt; oneWithIdSubType(
		DataFetchingEnvironment dataFetchingEnvironment, DataLoader&lt;UUID, AllFieldCasesWithIdSubtype&gt; dataLoader,
		AllFieldCases source, Boolean uppercase) {
	return dataLoader.load(UUID.randomUUID());
}
</pre>
<p>then, in the <i>AllFieldCasesWithIdSubtype</i> DataFetcherDelegate, you can retrieve the uppercase this way:</p>
<pre>
@Override
public List&lt;AllFieldCasesWithIdSubtype&gt; batchLoader(List&lt;UUID&gt; keys, BatchLoaderEnvironment environment) {
	List&lt;AllFieldCasesWithIdSubtype&gt; list = new ArrayList&lt;&gt;(keys.size());
	for (UUID id : keys) {
		// Let's manage the uppercase parameter, that was associated with this key
		Boolean uppercase = (Boolean) environment.getKeyContexts().get(id);
		if (uppercase != null &amp;&amp; uppercase) {
			item.setName(item.getName().toUpperCase());
		}

		// Do something with the id and the uppercase value
	}
	return list;
}
</pre>
<p>For more complex cases, you can store a <code>java.util.Map</code><!-- no javadoc sites associated --> with all the needed values, instead of just the parameter value.</p>
<p><b><i>The default value changed since 2.0 version: it is false in 1.x version, and true since the 2.0 version</i></b></p><br /><strong>Default</strong>: <code>true</code><br /><strong>User Property</strong>: <code>com.graphql_java_generator.mavenplugin.generateBatchLoaderEnvironment</code></td></tr>
<tr class="a">
<td style="text-align: left;"><a href="#generateBatchMappingDataFetchers"><code>&lt;generateBatchMappingDataFetchers&gt;</code></a></td>
<td><code>boolean</code></td>
<td><code>-</code></td>
<td><p>If this parameter is set to <i>true</i>, the spring GraphQL controller methods will be annotated with the <code>@BatchMapping</code> (instead of the <code>@SchemaMapping</code>). This allows to manage the of the N+1 select problem: so this allows much better performances, by highly diminishing the number of executed requests (avoid to execute several times the same "sub-query")</p>
<p></p> When setting this parameter to <i>true</i>, the main changes are: 
<p></p>
<ul>
 <li>The <code>@BatchMapping</code> annotation may be applied to all data fetchers without argument(s) that return either a List, a Type, an Interface or an Union.</li>
 <li>The return type must be defined in the controller: it may not be `Object`, as spring-graphql builds the proper BatchLoader while loading the controllers, when the server starts. The return type for this method is managed by the <code>batchMappingMethodReturnType</code> plugin parameter</li>
 <li>DataLoader is managed transparently by spring (instead of having to declare it in the generated controller, and having it as a parameter in the generated data fetchers)</li>
 <li>The batch mapping is generalized on all data fetchers</li>
 <li>The <code>DataFetchersDelegate</code> method's signature changes</li>
 <li>The <code>generateBatchLoaderEnvironment</code>, <code>generateDataFetcherForEveryFieldsWithArguments</code> and <code>generateDataLoaderForLists</code> plugin parameters are ignored</li>
</ul>
<p>A typical method signature for a data fetcher would be as below, where the return type is controller by the <code>batchMappingMethodReturnType</code> plugin parameter :</p>
<pre>
public Flux<topic> topics(//
		BatchLoaderEnvironment batchLoaderEnvironment, //
		GraphQLContext graphQLContext, //
		List<board> boards);
</board></topic></pre>
<p>Please note that the <code>@BatchMapping</code> annotation is a shortcut to avoid boilerplate code, for the most common cases. See <a href="https://github.com/spring-projects/spring-graphql/issues/232">this discussion</a> for more information on this. For most complex cases, the use of a DataLoader is recommended by the spring-graphql case. And in these cases, the plugin will generate a method with the <code>@SchemaMapping</code> annotation</p><br /><strong>Default</strong>: <code>false</code><br /><strong>User Property</strong>: <code>com.graphql_java_generator.mavenplugin.generateBatchMappingDataFetchers</code></td></tr>
<tr class="b">
<td style="text-align: left;"><a href="#generateDataFetcherForEveryFieldsWithArguments"><code>&lt;generateDataFetcherForEveryFieldsWithArguments&gt;</code></a></td>
<td><code>boolean</code></td>
<td><code>-</code></td>
<td><p>(only for server mode, since 2.5) Defines if a data fetcher is needed for every GraphQL field that has input argument, and add them in the generated POJOs. This allows a better compatibility with spring-graphql, and an easy access to the field's parameters.</p>
<p>This parameter is <b>forced to true</b> when the <code>generateBatchMappingDataFetchers</code> parameter is set to <i>true</i>.</p>
<p>With this argument to false, the data fetchers are generated only for field which type is a type (not a scalar or an enum), and for the query, mutation and subscription types.</p>
<p>With this argument to true, the data fetchers are generated for all GraphQL fields which type is a type (not a scalar or an enum) <b><i>or</i></b> that has one or arguments</p>
<p>This parameter is available since version 2.5:</p>
<ul>
 <li>From 2.5 to 3.0: Default value is false in 2.x versions for backward compatibility with existing implementations based on the plugin. But the <b>recommended value is true</b>.</li>
 <li>From 3.0.1: Default value is true</li>
</ul><br /><strong>Default</strong>: <code>true</code><br /><strong>User Property</strong>: <code>com.graphql_java_generator.mavenplugin.generateDataFetcherForEveryFieldsWithArguments</code></td></tr>
<tr class="a">
<td style="text-align: left;"><a href="#generateDataLoaderForLists"><code>&lt;generateDataLoaderForLists&gt;</code></a></td>
<td><code>boolean</code></td>
<td><code>-</code></td>
<td><p>(only for server mode) Defines how the methods in the data fetchers delegates are generated. The detailed information is available in the <a href="https://github.com/graphql-java-generator/graphql-maven-plugin-project/wiki/server">Wiki server page</a></p>
<p>When generateDataLoaderForLists is false (default mode), the data loaders are used only for fields that don't return a list. In other words, for fields which type is a sub-object with an id, two methods are generated: one which returns a <code>java.util.concurrent.CompletableFuture</code><!-- no javadoc sites associated -->, and one which returns a none <code>java.util.concurrent.CompletableFuture</code><!-- no javadoc sites associated --> result (that is used by the generated code only if no data loader is available).</p>
<p>When generateDataLoaderForLists is true, the above behavior is extended to fields that are a list.</p>
<p>Note: if set to true, this plugin parameter make the use of data loader mandatory for every field which type is a list of GraphQL objects, which have an id. This may not be suitable, for instance when your data is stored in a relational database, where you would need a first query to retrieve the ids and push them into the data loader, then another one to retrieve the associated values. If you want to use data loader for only some of particular fields, you should <b>consider using the <code>generateDataLoaderForLists</code></b>. You'll find more information on the <a href="https://github.com/graphql-java-generator/graphql-maven-plugin-project/wiki/server">Wiki server page</a>.</p>
<p>This parameter is available since version 1.18.4</p><br /><strong>Default</strong>: <code>false</code><br /><strong>User Property</strong>: <code>com.graphql_java_generator.mavenplugin.generateDataLoaderForLists</code></td></tr>
<tr class="b">
<td style="text-align: left;"><a href="#generateDeprecatedRequestResponse"><code>&lt;generateDeprecatedRequestResponse&gt;</code></a></td>
<td><code>boolean</code></td>
<td><code>-</code></td>
<td><p><i>(since 1.7.1 version) Default value is _true_ for 1.x version, and _false_ for version 2.0 and after.</i></p>
<p>If this parameter is set to true, the plugin generates a XxxxResponse class for each query/mutation/subscription, and (if separateUtilityClasses is true) Xxxx classes in the util subpackage. This allows to keep compatibility with code Developed with the 1.x versions of the plugin.</p>
<p>The recommended way to use the plugin is to directly use the Xxxx query/mutation/subscription executor classes, where Xxxx is the query/mutation/subscription name defined in the GraphQL schema. To do this, set this parameter to _false_, and use the plugin as described in the <a href="https://github.com/graphql-java-generator/graphql-maven-plugin-project/wiki/client_spring">wiki client page</a>.</p><br /><strong>Default</strong>: <code>false</code><br /><strong>User Property</strong>: <code>com.graphql_java_generator.mavenplugin.generateDeprecatedRequestResponse</code></td></tr>
<tr class="a">
<td style="text-align: left;"><a href="#generateJPAAnnotation"><code>&lt;generateJPAAnnotation&gt;</code></a></td>
<td><code>boolean</code></td>
<td><code>-</code></td>
<td><p>(only for server mode) Indicates whether the plugin should generate the JPA annotations, for generated objects.</p>
<p>Note: if the generated code must be used with Spring 3, you must set the <i>useJakartaEE9</i> plugin parameter to <i>true</i>.</p>
<p><b><i>Default value is false</i></b></p><br /><strong>Default</strong>: <code>false</code><br /><strong>User Property</strong>: <code>com.graphql_java_generator.mavenplugin.generateJPAAnnotation</code></td></tr>
<tr class="b">
<td style="text-align: left;"><a href="#ignoredSpringMappings"><code>&lt;ignoredSpringMappings&gt;</code></a></td>
<td><code>String</code></td>
<td><code>-</code></td>
<td><p>This parameter marks a list of GraphQL mappings as ignored, so that they are not generated by the plugin. These ignored mappings can then be defined by the specific implementation.</p>
<p>The other way to it is to create a spring GraphQL Controller, that overrides the controller generated by the plugin. But this may lead to this error: <code>Ambiguous mapping. Cannot map 'xxxController' method [...] to 'Type.field': there is already 'yyy' bean method [...] mapped.</code></p>
<p>The parameter may contain:</p>
<ul>
 <li>The '*' character: this would mark all controllers and DataFetchersDeleagate to be ignored. That is: none would be generated, and it's up to the specific implementation to manage them. In this mode, you still benefit of the POJO generation, the type wiring, the custom scalars mapping...</li>
 <li>A list of:</li>
 <ul>
  <li>GraphQL type name: The full controller class for this type is ignored, and won't be generated</li>
  <li>GraphQL type's field name: The method in the controller of this type, for this field, is ignored, and won't be generated. The field must be written like this: <code>{type name}.{field name}</code></li>
 </ul>
</ul>
<p>The accepted separators for the values are: comma, space, carriage return, end of line, space, tabulation. At least one separator must exist between two values in the list. Here is a sample:</p>
<pre>
         <ignoredspringmappings>Type1, Type2.field1
         	Type3
         	Type4.field2
         </ignoredspringmappings>
</pre>
<p>For field mapping, there must be no separator other than '.' between the type name and the field name. For instance, the following type declaration are invalid: 'type .field', 'type. field'</p>
<p>To implement the ignored mappings, you'll have to follow the [spring-graphql documentation](https://docs.spring.io/spring-graphql/reference/controllers.html).</p><br /><strong>User Property</strong>: <code>com.graphql_java_generator.mavenplugin.ignoredSpringMappings</code></td></tr>
<tr class="a">
<td style="text-align: left;"><a href="#inputPrefix"><code>&lt;inputPrefix&gt;</code></a></td>
<td><code>String</code></td>
<td><code>-</code></td>
<td>An optional prefix to add to the classnames of the generated java classes for GraphQL input objects. The prefix is added at the beginning of the java classname, and must be compatible with java naming rules (no space, dot, comma, etc.)<br /><strong>User Property</strong>: <code>com.graphql_java_generator.mavenplugin.inputPrefix</code></td></tr>
<tr class="b">
<td style="text-align: left;"><a href="#inputSuffix"><code>&lt;inputSuffix&gt;</code></a></td>
<td><code>String</code></td>
<td><code>-</code></td>
<td>An optional suffix to add to the classnames of the generated java classes for GraphQL input objects. The suffix is added at the end of the java classname, and must be compatible with java naming rules (no space, dot, comma, etc.)<br /><strong>User Property</strong>: <code>com.graphql_java_generator.mavenplugin.javaClassSuffix</code></td></tr>
<tr class="a">
<td style="text-align: left;"><a href="#interfacePrefix"><code>&lt;interfacePrefix&gt;</code></a></td>
<td><code>String</code></td>
<td><code>-</code></td>
<td>An optional prefix to add to the classnames of the generated java classes for GraphQL interfaces. The prefix is added at the beginning of the java classname, and must be compatible with java naming rules (no space, dot, comma, etc.)<br /><strong>User Property</strong>: <code>com.graphql_java_generator.mavenplugin.interfacePrefix</code></td></tr>
<tr class="b">
<td style="text-align: left;"><a href="#interfaceSuffix"><code>&lt;interfaceSuffix&gt;</code></a></td>
<td><code>String</code></td>
<td><code>-</code></td>
<td>An optional suffix to add to the classnames of the generated java classes for GraphQL interfaces. The suffix is added at the end of the java classname, and must be compatible with java naming rules (no space, dot, comma, etc.)<br /><strong>User Property</strong>: <code>com.graphql_java_generator.mavenplugin.interfaceSuffix</code></td></tr>
<tr class="a">
<td style="text-align: left;"><a href="#javaTypeForIDType"><code>&lt;javaTypeForIDType&gt;</code></a></td>
<td><code>String</code></td>
<td><code>-</code></td>
<td><p>The <i>javaTypeForIDType</i> is the java class that is used in the generated code for GraphQL fields that are of the GraphQL ID type. The default value is <i>java.util.UUID</i>. Valid values are: java.lang.String, java.lang.Long and java.util.UUID.</p>
<p>This parameter is only valid for the server mode. When generating the client code, the ID is always generated as a String type, as recommended in the GraphQL doc.</p>
<p>In other words: when in server mode and <i>javaTypeForIDType</i> is not set, all GraphQL ID fields are UUID attributes in java. When in server mode and <i>javaTypeForIDType</i> is set to the X type, all GraphQL ID fields are X attributes in java.</p>
<p>Note: you can override this, by using the schema personalization capability. For more information, please have a look at the <a href="https://github.com/graphql-java-generator/graphql-maven-plugin-project/wiki/usage_schema_personalization">Schema Personalization doc page</a>.</p><br /><strong>Default</strong>: <code>java.util.UUID</code><br /><strong>User Property</strong>: <code>com.graphql_java_generator.mavenplugin.javaTypeForIDType</code></td></tr>
<tr class="b">
<td style="text-align: left;"><a href="#jsonGraphqlSchemaFilename"><code>&lt;jsonGraphqlSchemaFilename&gt;</code></a></td>
<td><code>String</code></td>
<td><code>-</code></td>
<td>No description.<br /><strong>User Property</strong>: <code>com.graphql_java_generator.mavenplugin.jsonGraphqlSchemaFilename</code></td></tr>
<tr class="a">
<td style="text-align: left;"><a href="#maxTokens"><code>&lt;maxTokens&gt;</code></a></td>
<td><code>Integer</code></td>
<td><code>-</code></td>
<td><i>(Useless, since 1.18.7)</i>Defines the options that maximum number of tokens that the GraphQL schema parser may read. The default value is Integer.MAX_VALUE (=2147483647). If the schema contains more than <i>maxTokens</i>, the build will fail with an error.<br /><strong>Default</strong>: <code>2147483647</code><br /><strong>User Property</strong>: <code>com.graphql_java_generator.mavenplugin.maxTokens</code></td></tr>
<tr class="b">
<td style="text-align: left;"><a href="#mode"><code>&lt;mode&gt;</code></a></td>
<td><code>PluginMode</code></td>
<td><code>-</code></td>
<td>The generation mode: either <i>client</i> or <i>server</i>. Choose client to generate the code which can query a graphql server or server to generate a code for the server side.<br /><strong>Default</strong>: <code>client</code><br /><strong>User Property</strong>: <code>com.graphql_java_generator.mavenplugin.mode</code></td></tr>
<tr class="a">
<td style="text-align: left;"><a href="#packageName"><code>&lt;packageName&gt;</code></a></td>
<td><code>String</code></td>
<td><code>-</code></td>
<td>The package name that will contain the generated classes<br /><strong>Default</strong>: <code>com.generated.graphql</code><br /><strong>User Property</strong>: <code>com.graphql_java_generator.mavenplugin.packageName</code></td></tr>
<tr class="b">
<td style="text-align: left;"><a href="#projectBuildDir"><code>&lt;projectBuildDir&gt;</code></a></td>
<td><code>File</code></td>
<td><code>-</code></td>
<td>No description.<br /><strong>Default</strong>: <code>${project.build.directory}</code></td></tr>
<tr class="a">
<td style="text-align: left;"><a href="#queryMutationExecutionProtocol"><code>&lt;queryMutationExecutionProtocol&gt;</code></a></td>
<td><code>QueryMutationExecutionProtocol</code></td>
<td><code>-</code></td>
<td>(since 2.0RC1) The <code>com.graphql_java_generator.plugin.conf.QueryMutationExecutionProtocol</code><!-- no javadoc sites associated --> to use for GraphQL queries and mutations (not subscriptions). The allowed values are: http and webSocket.
<br />
 The default value is http.<br /><strong>Default</strong>: <code>http</code><br /><strong>User Property</strong>: <code>com.graphql_java_generator.mavenplugin.queryMutationExecutionProtocol</code></td></tr>
<tr class="b">
<td style="text-align: left;"><a href="#scanBasePackages"><code>&lt;scanBasePackages&gt;</code></a></td>
<td><code>String</code></td>
<td><code>-</code></td>
<td><p>(only for server mode) A comma separated list of package names, <b>without</b> double quotes, that will also be parsed by Spring, to discover Spring beans, Spring repositories and JPA entities when the server starts. You should use this parameter only for packages that are not subpackage of the package defined in the _packageName_ parameter and not subpackage of <i>com.graphql_java_generator</i></p>
<p>This allows for instance, to set <i>packageName</i> to <i>your.app.package.graphql</i>, and to define your Spring beans, like the <a href="https://graphql-maven-plugin-project.graphql-java-generator.com/server.html">DataFetcherDelegates</a> or your Spring data repositories in any other folder, by setting for instance scanBasePackages to <i>your.app.package.impl, your.app.package.graphql</i>, or just <i>your.app.package</i></p><br /><strong>Default</strong>: <code>null</code><br /><strong>User Property</strong>: <code>com.graphql_java_generator.mavenplugin.scanBasePackages</code></td></tr>
<tr class="a">
<td style="text-align: left;"><a href="#schemaFileFolder"><code>&lt;schemaFileFolder&gt;</code></a></td>
<td><code>File</code></td>
<td><code>-</code></td>
<td><p>The folder which contains the GraphQL schema file(s) , typically <code>/src/main/resources</code> of the current project. That's where the GraphQL schema(s) are expected to be: in this folder, or one of these subfolders. If the <code>jsonSchemaFilename</code> is set, then this parameter controls where this json schema file is.</p>
<p><u>Caution:</u> this default value for this folder is <code>/src/main/resources</code>, for compatibility with first versions of this plugin. It's different from the spring-graphql default one, which is <i>/src/main/resources/graphql</i></p><br /><strong>Default</strong>: <code>src/main/resources</code><br /><strong>User Property</strong>: <code>com.graphql_java_generator.mavenplugin.schemaFileFolder</code></td></tr>
<tr class="b">
<td style="text-align: left;"><a href="#schemaFilePattern"><code>&lt;schemaFilePattern&gt;</code></a></td>
<td><code>String</code></td>
<td><code>-</code></td>
<td><p>The pattern to find the graphql schema file(s). The default value is "/*.graphqls" meaning that the maven plugin will search all graphqls files in the "/src/main/resources" folder (please check also the <i>schemaFileFolder</i> plugin parameter).</p>
<p>You can put the star (*) joker in the filename, to retrieve several files at ones, for instance <i>/myschema*.graphqls</i> will retrieve the <i>/src/main/resources/myschema.graphqls</i> and <i>/src/main/resources/myschema_extend.graphqls</i> files.</p>
<p></p><br /><strong>Default</strong>: <code>*.graphqls</code><br /><strong>User Property</strong>: <code>com.graphql_java_generator.mavenplugin.schemaFilePattern</code></td></tr>
<tr class="a">
<td style="text-align: left;"><a href="#schemaPersonalizationFile"><code>&lt;schemaPersonalizationFile&gt;</code></a></td>
<td><code>String</code></td>
<td><code>-</code></td>
<td><p>schemaPersonalizationFile is the file name where the GraphQL maven plugin will find personalization that it must apply before generating the code. Since the 2.2 release, it is available for both client and server. Before, it applies to the <b>server</b> mode only.</p>
<p></p>
<p>This allows to:</p>
<ul>
 <li>Add or modify fields</li>
 <li>Add interface and annotation to classes (GraphQL types, input types, interfaces, unions and enums) or fields.</li>
</ul>
<p></p>
<p>See <a href="https://github.com/graphql-java-generator/graphql-maven-plugin-project/wiki/usage_schema_personalization">the doc on the project's wiki</a> for more details.</p><br /><strong>Default</strong>: <code>null</code><br /><strong>User Property</strong>: <code>com.graphql_java_generator.mavenplugin.schemaPersonalizationFile</code></td></tr>
<tr class="b">
<td style="text-align: left;"><a href="#separateUtilityClasses"><code>&lt;separateUtilityClasses&gt;</code></a></td>
<td><code>boolean</code></td>
<td><code>-</code></td>
<td><p>Indicates whether the utility classes (that is: the classes that are not match an item in the GraphQL schema) are generated in the same package than the classes that matches the GraphQL schema.</p>
<p>The classes that map the GraphQL schema (type, input type, interfaces, unions...) are <b>generated</b> in the package defined in the <i>packageName</i> plugin parameter, then:</p>
<ul>
 <li>If false <i>(default for versions 1.x)</i>, the utility classes are generated in the the same package</li>
 <li>If true <i>(default for version 2.0 and after)</i>, the utility classes are generated in the <i>util</i> subpackage of this package</li>
</ul><br /><strong>Default</strong>: <code>true</code><br /><strong>User Property</strong>: <code>com.graphql_java_generator.mavenplugin.separateUtilityClasses</code></td></tr>
<tr class="a">
<td style="text-align: left;"><a href="#skipGenerationIfSchemaHasNotChanged"><code>&lt;skipGenerationIfSchemaHasNotChanged&gt;</code></a></td>
<td><code>boolean</code></td>
<td><code>-</code></td>
<td><p>This parameter is now <b><i>deprecated</i></b>: it's value used in the plugin is always true, that is: if the generated sources or resources are older than the GraphQL schema file(s), then there is no source or resource generation. In clear, the source and resource generation is executed only if the provided input (GraphQL schema...) has been updated since the last plugin execution.</p><br /><strong>Default</strong>: <code>true</code><br /><strong>User Property</strong>: <code>com.graphql_java_generator.mavenplugin.skipGenerationIfSchemaHasNotChanged</code></td></tr>
<tr class="b">
<td style="text-align: left;"><a href="#sourceEncoding"><code>&lt;sourceEncoding&gt;</code></a></td>
<td><code>String</code></td>
<td><code>-</code></td>
<td>The encoding charset for the generated source files<br /><strong>Default</strong>: <code>UTF-8</code><br /><strong>User Property</strong>: <code>com.graphql_java_generator.mavenplugin.sourceEncoding</code></td></tr>
<tr class="a">
<td style="text-align: left;"><a href="#springBeanSuffix"><code>&lt;springBeanSuffix&gt;</code></a></td>
<td><code>String</code></td>
<td><code>-</code></td>
<td>Retrieves the suffix that will be applied to the name of the Spring Beans that are generated for this schema. It's mandatory if you' using a Spring app and have more than one GraphQL schemas. The default value is an empty String.<br /><strong>User Property</strong>: <code>com.graphql_java_generator.mavenplugin.springBeanSuffix</code></td></tr>
<tr class="b">
<td style="text-align: left;"><a href="#targetResourceFolder"><code>&lt;targetResourceFolder&gt;</code></a></td>
<td><code>File</code></td>
<td><code>-</code></td>
<td>The folder where resources will be generated<br /><strong>Default</strong>: <code>${project.build.directory}/generated-resources/graphql-maven-plugin</code><br /><strong>User Property</strong>: <code>com.graphql_java_generator.mavenplugin.targetResourceFolder</code></td></tr>
<tr class="a">
<td style="text-align: left;"><a href="#targetSchemaSubFolder"><code>&lt;targetSchemaSubFolder&gt;</code></a></td>
<td><code>String</code></td>
<td><code>-</code></td>
<td><p>Defines the folder in the classpath that will contain the GraphQL schema, as needed by spring-graphql. The default is the default for spring-graphql, that is: graphql.</p>
<p>Note: If you change this plugin parameter, you must then also define the spring property spring.graphql.schema.location to "classpath*:yourGraphQLSchemaFolder/, in you application.properties or application.yml project file.</p> * 
<p>Since 3.0.x</p> * 
<p>Mandatory if you're using JPMS (java modules), as the default folder is /graphql, which triggers a conflict with the graphql package exposed by graphql-java</p><br /><strong>Default</strong>: <code>graphql</code><br /><strong>User Property</strong>: <code>com.graphql_java_generator.mavenplugin.targetSchemaSubFolder</code></td></tr>
<tr class="b">
<td style="text-align: left;"><a href="#targetSourceFolder"><code>&lt;targetSourceFolder&gt;</code></a></td>
<td><code>File</code></td>
<td><code>-</code></td>
<td><p>The folder where source code for the generated classes will be generated</p>
<p>The default value is $</p><br /><strong>Default</strong>: <code>${project.build.directory}/generated-sources/graphql-maven-plugin</code><br /><strong>User Property</strong>: <code>com.graphql_java_generator.mavenplugin.targetSourceFolder</code></td></tr>
<tr class="a">
<td style="text-align: left;"><a href="#templates"><code>&lt;templates&gt;</code></a></td>
<td><code>Map&lt;String,String&gt;</code></td>
<td><code>-</code></td>
<td><p>Map of the code templates to be used: this allows to override the default templates, and control exactly what code is generated by the plugin.</p>
<p>You can override any of the Velocity templates of the project. The list of templates is defined in the enum CodeTemplate, that you can <a href="https://github.com/graphql-java-generator/graphql-maven-plugin-project/blob/master/graphql-maven-plugin-logic/src/main/java/com/graphql_java_generator/plugin/CodeTemplate.java">check here</a>.</p>
<p>You can find a sample in the <a href="https://github.com/graphql-java-generator/graphql-maven-plugin-project/blob/master/graphql-maven-plugin-samples/graphql-maven-plugin-samples-CustomTemplates-client/pom.xml">CustomTemplates client sample</a>.</p>
<p><b>Important notice:</b> Please note that the default templates may change in the future. And some of these modifications would need to be reported into the custom templates. We'll try to better expose a stable public API in the future.</p><br /><strong>User Property</strong>: <code>com.graphql_java_generator.mavenplugin.templates</code></td></tr>
<tr class="b">
<td style="text-align: left;"><a href="#typePrefix"><code>&lt;typePrefix&gt;</code></a></td>
<td><code>String</code></td>
<td><code>-</code></td>
<td>An optional prefix to add to the classnames of the generated java classes for GraphQL types. The prefix is added at the beginning of the java classname, and must be compatible with java naming rules (no space, dot, comma, etc.)<br /><strong>User Property</strong>: <code>com.graphql_java_generator.mavenplugin.typePrefix</code></td></tr>
<tr class="a">
<td style="text-align: left;"><a href="#typeSuffix"><code>&lt;typeSuffix&gt;</code></a></td>
<td><code>String</code></td>
<td><code>-</code></td>
<td>An optional suffix to add to the classnames of the generated java classes for GraphQL types. The suffix is added at the end of the java classname, and must be compatible with java naming rules (no space, dot, comma, etc.)<br /><strong>User Property</strong>: <code>com.graphql_java_generator.mavenplugin.typeSuffix</code></td></tr>
<tr class="b">
<td style="text-align: left;"><a href="#unionPrefix"><code>&lt;unionPrefix&gt;</code></a></td>
<td><code>String</code></td>
<td><code>-</code></td>
<td>An optional prefix to add to the classnames of the generated java classes for GraphQL unions. The prefix is added at the beginning of the java classname, and must be compatible with java naming rules (no space, dot, comma, etc.)<br /><strong>User Property</strong>: <code>com.graphql_java_generator.mavenplugin.unionPrefix</code></td></tr>
<tr class="a">
<td style="text-align: left;"><a href="#unionSuffix"><code>&lt;unionSuffix&gt;</code></a></td>
<td><code>String</code></td>
<td><code>-</code></td>
<td>An optional suffix to add to the classnames of the generated java classes for GraphQL unions. The suffix is added at the end of the java classname, and must be compatible with java naming rules (no space, dot, comma, etc.)<br /><strong>User Property</strong>: <code>com.graphql_java_generator.mavenplugin.unionSuffix</code></td></tr>
<tr class="b">
<td style="text-align: left;"><a href="#useJakartaEE9"><code>&lt;useJakartaEE9&gt;</code></a></td>
<td><code>boolean</code></td>
<td><code>-</code></td>
<td><p>(since 2.0RC1) If false, it uses jakarta EE8 imports (that begins by javax.). If true, it uses jakarta EE8 imports (that begins by jakarta.).</p>
<p>(since 3.0) The parameter is ignored. Its value is always true.</p><br /><strong>Default</strong>: <code>true</code><br /><strong>User Property</strong>: <code>com.graphql_java_generator.mavenplugin.useJakartaEE9</code></td></tr></table></section><section>
<h2>Parameter Details</h2><a id="Parameter_Details"></a><a id="addRelayConnections"></a><section>
<h3>&lt;addRelayConnections&gt;</h3><a id="a.3CaddRelayConnections.3E"></a>
<div><p>True if the plugin is configured to add the Relay connection capabilities to the field marked by the <i>@RelayConnection</i> directive.</p>
<p>If so, the plugin reads the provided GraphQL schema file(s), and enriches them with the interfaces and types needed to respect the Relay Connection specification. The entry point for that is the <i>@RelayConnection</i> directive.</p>
<p>You'll find all the information on the plugin web site. Please check the <a href="https://graphql-maven-plugin-project.graphql-java-generator.com/client_add_relay_connection.html>client
Relay capability page&lt;/A> or the &lt;A
HREF=" https:="" graphql-maven-plugin-project.graphql-java-generator.com="" server_add_relay_connection.html="">server Relay capability page</a>.</p></div>
<ul>
<li><strong>Type</strong>: <code>boolean</code></li>
<li><strong>Required</strong>: <code>No</code></li>
<li><strong>User Property</strong>: <code>com.graphql_java_generator.mavenplugin.addRelayConnections</code></li>
<li><strong>Default</strong>: <code>false</code></li></ul><hr /></section><a id="batchMappingDataFetcherReturnType"></a><section>
<h3>&lt;batchMappingDataFetcherReturnType&gt;</h3><a id="a.3CbatchMappingDataFetcherReturnType.3E"></a>
<div><p>This parameter is used only when generateBatchMappingDataFetchers is set to <i>true</i>. It determines the return type of the data fetchers, as defined in the <a href="https://docs.spring.io/spring-graphql/reference/controllers.html#controllers.batch-mapping.return.values">spring-graphql documentation</a>.</p>
<p>The allowed values are (where K is the key type, that is: the parent object, and V is the value to be loaded in batch):</p><row>
</row><row>
</row><row>
</row><row>
</row><row>
</row>
<table>
 <tbody>
  <tr>
   <th>Value</th>
   <th>Return type</th>
   <td>MONO_MAP</td>Mono&lt;Map&lt;K,V&gt;&gt;
   <td>MAP</td>
   <td>Map&lt;K,V&gt;</td>
   <td>FLUX&gt;</td>
   <td>Flux&lt;V&gt;</td>
   <td>COLLECTION</td>
   <td>Collection&lt;V&gt;</td>
  </tr>
 </tbody>
</table>
<p>The default value is <code>Flux&lt;V&gt;</code></p>
<p>For an easier use of this parameter, the comment of the generated data fetchers details the exact expected type.</p></div>
<ul>
<li><strong>Type</strong>: <code>com.graphql_java_generator.plugin.conf.BatchMappingDataFetcherReturnType</code></li>
<li><strong>Required</strong>: <code>No</code></li>
<li><strong>User Property</strong>: <code>com.graphql_java_generator.mavenplugin.batchMappingDataFetcherReturnType</code></li>
<li><strong>Default</strong>: <code>FLUX</code></li></ul><hr /></section><a id="copyRuntimeSources"></a><section>
<h3>&lt;copyRuntimeSources&gt;</h3><a id="a.3CcopyRuntimeSources.3E"></a>
<div><p>Flag to enable (or not) the copy of the sources from the graphql-java-runtime library to target source code directory. That is: it allows to control whether the runtime code is embedded in the generated code or not.</p>
<p><b>Caution:</b> the default value changed since the 2.0 version. In 1.x version, the default value is true. Since 2.0 version, the default value is false.</p>
<ul>
 <li>If copyRuntimeSources=true: the runtime is copied along with the generated code. The project configuration (pom.xml or build.gradle) must contain the <code>com.graphql-java-generator:graphql-java-dependencies</code> dependency, with the same version as the GraphQL plugin</li>
 <li>If copyRuntimeSources=false: the runtime is NOT copied along with the generated code. The project configuration (pom.xml or build.gradle) must contain the <code>com.graphql-java-generator:graphql-java-runtime</code> dependency, with the same version as the GraphQL plugin</li>
 <li></li>
</ul></div>
<ul>
<li><strong>Type</strong>: <code>boolean</code></li>
<li><strong>Required</strong>: <code>No</code></li>
<li><strong>User Property</strong>: <code>com.graphql_java_generator.mavenplugin.copyRuntimeSources</code></li>
<li><strong>Default</strong>: <code>false</code></li></ul><hr /></section><a id="customScalars"></a><section>
<h3>&lt;customScalars&gt;</h3><a id="a.3CcustomScalars.3E"></a>
<div><p>This parameter contains the list of custom scalars implementations. One such implementation must be provided for each custom scalar defined in the GraphQL implemented by the project for its GraphQL schema. It's a list, where the key is the scalar name, as defined in the GraphQL schema, and the value is the full class name of the implementation of <code>graphql.schema.GraphQLScalarType</code><!-- no javadoc sites associated -->.</p>
<p>This parameter is a list of customScalars. For each one, you must define the name, the javaType and exactly one of these fields: graphQLScalarTypeClass, graphQLScalarTypeStaticField or graphQLScalarTypeGetter.</p>
<p>Here is the detail:</p>
<ul>
 <li><b>graphQLTypeName</b>: The type name, as defined in the GraphQL schema, for instance <i>Date</i></li>
 <li><b>javaType</b>: The full class name for the java type that contains the data for this type, once in the Java code, for instance <i>java.util.Date</i></li>
 <li><b>graphQLScalarTypeClass</b>: The full class name for the <code>graphql.schema.GraphQLScalarType</code><!-- no javadoc sites associated --> that will manage this Custom Scalar. This class must be a subtype of <code>graphql.schema.GraphQLScalarType</code><!-- no javadoc sites associated -->. Bu the constructor of <code>graphql.schema.GraphQLScalarType</code><!-- no javadoc sites associated --> has been deprecated, so you'll find no sample for that in this project</li>
 <li><b>graphQLScalarTypeStaticField</b>: The full class name followed by the static field name that contains the <code>graphql.schema.GraphQLScalarType</code><!-- no javadoc sites associated --> that will manage this Custom Scalar. For instance, the graphql-java package provides several custom scalars like <i>graphql.Scalars.GraphQLLong</i>. You can also use the <i>graphql-java-extended-scalars</i> project, that provides other custom scalars like <i>graphql.scalars.ExtendedScalars.NonNegativeInt</i>.</li>
 <li><b>graphQLScalarTypeGetter</b>: The full class name followed by the static method name that returns the <code>graphql.schema.GraphQLScalarType</code><!-- no javadoc sites associated --> that will manage this Custom Scalar. For instance: <i>org.mycompany.MyScalars.getGraphQLLong()</i> or <i>com.graphql_java_generator.customscalars.GraphQLScalarTypeDate</i>. This call may contain parameters, provided that this a valid java command.</li>
</ul>
<p>Please have a look at the allGraphQLCases (both client and server) samples for more information. The <a href="https://github.com/graphql-java-generator/graphql-maven-plugin-project/blob/master/graphql-maven-plugin-samples/graphql-maven-plugin-samples-allGraphQLCases-client/pom.xml">allGraphQLCases client pom</a> is a good sample.</p></div>
<ul>
<li><strong>Type</strong>: <code>java.util.List&lt;com.graphql_java_generator.plugin.conf.CustomScalarDefinition&gt;</code></li>
<li><strong>Required</strong>: <code>No</code></li>
<li><strong>User Property</strong>: <code>com.graphql_java_generator.mavenplugin.customScalars</code></li></ul><hr /></section><a id="enumPrefix"></a><section>
<h3>&lt;enumPrefix&gt;</h3><a id="a.3CenumPrefix.3E"></a>
<div>An optional prefix to add to the classnames of the generated java classes for GraphQL enums. The prefix is added at the beginning of the java classname, and must be compatible with java naming rules (no space, dot, comma, etc.)</div>
<ul>
<li><strong>Type</strong>: <code>java.lang.String</code></li>
<li><strong>Required</strong>: <code>No</code></li>
<li><strong>User Property</strong>: <code>com.graphql_java_generator.mavenplugin.enumPrefix</code></li></ul><hr /></section><a id="enumSuffix"></a><section>
<h3>&lt;enumSuffix&gt;</h3><a id="a.3CenumSuffix.3E"></a>
<div>An optional suffix to add to the classnames of the generated java classes for GraphQL enums. The suffix is added at the end of the java classname, and must be compatible with java naming rules (no space, dot, comma, etc.)</div>
<ul>
<li><strong>Type</strong>: <code>java.lang.String</code></li>
<li><strong>Required</strong>: <code>No</code></li>
<li><strong>User Property</strong>: <code>com.graphql_java_generator.mavenplugin.enumSuffix</code></li></ul><hr /></section><a id="generateBatchLoaderEnvironment"></a><section>
<h3>&lt;generateBatchLoaderEnvironment&gt;</h3><a id="a.3CgenerateBatchLoaderEnvironment.3E"></a>
<div><p>(only for server mode) Indicates if the plugin should generate add the <code>org.dataloader.BatchLoaderEnvironment</code><!-- no javadoc sites associated --> parameter to the <i>batchLoader</i> methods, in DataFetchersDelegate. This parameter allows to get the context of the Batch Loader, including the context associated to the id, when using the id has been added by the <code>org.dataloader.DataLoader.load(java.lang.Object,java.lang.Object)</code><!-- no javadoc sites associated --> method.</p>
<p>For instance, if you have the method below, for a field named <i>oneWithIdSubType</i> in a DataFetcherDelegate:</p>
<pre>
@Override
public CompletableFuture&lt;AllFieldCasesWithIdSubtype&gt; oneWithIdSubType(
		DataFetchingEnvironment dataFetchingEnvironment, DataLoader&lt;UUID, AllFieldCasesWithIdSubtype&gt; dataLoader,
		AllFieldCases source, Boolean uppercase) {
	return dataLoader.load(UUID.randomUUID());
}
</pre>
<p>then, in the <i>AllFieldCasesWithIdSubtype</i> DataFetcherDelegate, you can retrieve the uppercase this way:</p>
<pre>
@Override
public List&lt;AllFieldCasesWithIdSubtype&gt; batchLoader(List&lt;UUID&gt; keys, BatchLoaderEnvironment environment) {
	List&lt;AllFieldCasesWithIdSubtype&gt; list = new ArrayList&lt;&gt;(keys.size());
	for (UUID id : keys) {
		// Let's manage the uppercase parameter, that was associated with this key
		Boolean uppercase = (Boolean) environment.getKeyContexts().get(id);
		if (uppercase != null &amp;&amp; uppercase) {
			item.setName(item.getName().toUpperCase());
		}

		// Do something with the id and the uppercase value
	}
	return list;
}
</pre>
<p>For more complex cases, you can store a <code>java.util.Map</code><!-- no javadoc sites associated --> with all the needed values, instead of just the parameter value.</p>
<p><b><i>The default value changed since 2.0 version: it is false in 1.x version, and true since the 2.0 version</i></b></p></div>
<ul>
<li><strong>Type</strong>: <code>boolean</code></li>
<li><strong>Required</strong>: <code>No</code></li>
<li><strong>User Property</strong>: <code>com.graphql_java_generator.mavenplugin.generateBatchLoaderEnvironment</code></li>
<li><strong>Default</strong>: <code>true</code></li></ul><hr /></section><a id="generateBatchMappingDataFetchers"></a><section>
<h3>&lt;generateBatchMappingDataFetchers&gt;</h3><a id="a.3CgenerateBatchMappingDataFetchers.3E"></a>
<div><p>If this parameter is set to <i>true</i>, the spring GraphQL controller methods will be annotated with the <code>@BatchMapping</code> (instead of the <code>@SchemaMapping</code>). This allows to manage the of the N+1 select problem: so this allows much better performances, by highly diminishing the number of executed requests (avoid to execute several times the same "sub-query")</p>
<p></p> When setting this parameter to <i>true</i>, the main changes are: 
<p></p>
<ul>
 <li>The <code>@BatchMapping</code> annotation may be applied to all data fetchers without argument(s) that return either a List, a Type, an Interface or an Union.</li>
 <li>The return type must be defined in the controller: it may not be `Object`, as spring-graphql builds the proper BatchLoader while loading the controllers, when the server starts. The return type for this method is managed by the <code>batchMappingMethodReturnType</code> plugin parameter</li>
 <li>DataLoader is managed transparently by spring (instead of having to declare it in the generated controller, and having it as a parameter in the generated data fetchers)</li>
 <li>The batch mapping is generalized on all data fetchers</li>
 <li>The <code>DataFetchersDelegate</code> method's signature changes</li>
 <li>The <code>generateBatchLoaderEnvironment</code>, <code>generateDataFetcherForEveryFieldsWithArguments</code> and <code>generateDataLoaderForLists</code> plugin parameters are ignored</li>
</ul>
<p>A typical method signature for a data fetcher would be as below, where the return type is controller by the <code>batchMappingMethodReturnType</code> plugin parameter :</p>
<pre>
public Flux<topic> topics(//
		BatchLoaderEnvironment batchLoaderEnvironment, //
		GraphQLContext graphQLContext, //
		List<board> boards);
</board></topic></pre>
<p>Please note that the <code>@BatchMapping</code> annotation is a shortcut to avoid boilerplate code, for the most common cases. See <a href="https://github.com/spring-projects/spring-graphql/issues/232">this discussion</a> for more information on this. For most complex cases, the use of a DataLoader is recommended by the spring-graphql case. And in these cases, the plugin will generate a method with the <code>@SchemaMapping</code> annotation</p></div>
<ul>
<li><strong>Type</strong>: <code>boolean</code></li>
<li><strong>Required</strong>: <code>No</code></li>
<li><strong>User Property</strong>: <code>com.graphql_java_generator.mavenplugin.generateBatchMappingDataFetchers</code></li>
<li><strong>Default</strong>: <code>false</code></li></ul><hr /></section><a id="generateDataFetcherForEveryFieldsWithArguments"></a><section>
<h3>&lt;generateDataFetcherForEveryFieldsWithArguments&gt;</h3><a id="a.3CgenerateDataFetcherForEveryFieldsWithArguments.3E"></a>
<div><p>(only for server mode, since 2.5) Defines if a data fetcher is needed for every GraphQL field that has input argument, and add them in the generated POJOs. This allows a better compatibility with spring-graphql, and an easy access to the field's parameters.</p>
<p>This parameter is <b>forced to true</b> when the <code>generateBatchMappingDataFetchers</code> parameter is set to <i>true</i>.</p>
<p>With this argument to false, the data fetchers are generated only for field which type is a type (not a scalar or an enum), and for the query, mutation and subscription types.</p>
<p>With this argument to true, the data fetchers are generated for all GraphQL fields which type is a type (not a scalar or an enum) <b><i>or</i></b> that has one or arguments</p>
<p>This parameter is available since version 2.5:</p>
<ul>
 <li>From 2.5 to 3.0: Default value is false in 2.x versions for backward compatibility with existing implementations based on the plugin. But the <b>recommended value is true</b>.</li>
 <li>From 3.0.1: Default value is true</li>
</ul></div>
<ul>
<li><strong>Type</strong>: <code>boolean</code></li>
<li><strong>Required</strong>: <code>No</code></li>
<li><strong>User Property</strong>: <code>com.graphql_java_generator.mavenplugin.generateDataFetcherForEveryFieldsWithArguments</code></li>
<li><strong>Default</strong>: <code>true</code></li></ul><hr /></section><a id="generateDataLoaderForLists"></a><section>
<h3>&lt;generateDataLoaderForLists&gt;</h3><a id="a.3CgenerateDataLoaderForLists.3E"></a>
<div><p>(only for server mode) Defines how the methods in the data fetchers delegates are generated. The detailed information is available in the <a href="https://github.com/graphql-java-generator/graphql-maven-plugin-project/wiki/server">Wiki server page</a></p>
<p>When generateDataLoaderForLists is false (default mode), the data loaders are used only for fields that don't return a list. In other words, for fields which type is a sub-object with an id, two methods are generated: one which returns a <code>java.util.concurrent.CompletableFuture</code><!-- no javadoc sites associated -->, and one which returns a none <code>java.util.concurrent.CompletableFuture</code><!-- no javadoc sites associated --> result (that is used by the generated code only if no data loader is available).</p>
<p>When generateDataLoaderForLists is true, the above behavior is extended to fields that are a list.</p>
<p>Note: if set to true, this plugin parameter make the use of data loader mandatory for every field which type is a list of GraphQL objects, which have an id. This may not be suitable, for instance when your data is stored in a relational database, where you would need a first query to retrieve the ids and push them into the data loader, then another one to retrieve the associated values. If you want to use data loader for only some of particular fields, you should <b>consider using the <code>generateDataLoaderForLists</code></b>. You'll find more information on the <a href="https://github.com/graphql-java-generator/graphql-maven-plugin-project/wiki/server">Wiki server page</a>.</p>
<p>This parameter is available since version 1.18.4</p></div>
<ul>
<li><strong>Type</strong>: <code>boolean</code></li>
<li><strong>Required</strong>: <code>No</code></li>
<li><strong>User Property</strong>: <code>com.graphql_java_generator.mavenplugin.generateDataLoaderForLists</code></li>
<li><strong>Default</strong>: <code>false</code></li></ul><hr /></section><a id="generateDeprecatedRequestResponse"></a><section>
<h3>&lt;generateDeprecatedRequestResponse&gt;</h3><a id="a.3CgenerateDeprecatedRequestResponse.3E"></a>
<div><p><i>(since 1.7.1 version) Default value is _true_ for 1.x version, and _false_ for version 2.0 and after.</i></p>
<p>If this parameter is set to true, the plugin generates a XxxxResponse class for each query/mutation/subscription, and (if separateUtilityClasses is true) Xxxx classes in the util subpackage. This allows to keep compatibility with code Developed with the 1.x versions of the plugin.</p>
<p>The recommended way to use the plugin is to directly use the Xxxx query/mutation/subscription executor classes, where Xxxx is the query/mutation/subscription name defined in the GraphQL schema. To do this, set this parameter to _false_, and use the plugin as described in the <a href="https://github.com/graphql-java-generator/graphql-maven-plugin-project/wiki/client_spring">wiki client page</a>.</p></div>
<ul>
<li><strong>Type</strong>: <code>boolean</code></li>
<li><strong>Required</strong>: <code>No</code></li>
<li><strong>User Property</strong>: <code>com.graphql_java_generator.mavenplugin.generateDeprecatedRequestResponse</code></li>
<li><strong>Default</strong>: <code>false</code></li></ul><hr /></section><a id="generateJPAAnnotation"></a><section>
<h3>&lt;generateJPAAnnotation&gt;</h3><a id="a.3CgenerateJPAAnnotation.3E"></a>
<div><p>(only for server mode) Indicates whether the plugin should generate the JPA annotations, for generated objects.</p>
<p>Note: if the generated code must be used with Spring 3, you must set the <i>useJakartaEE9</i> plugin parameter to <i>true</i>.</p>
<p><b><i>Default value is false</i></b></p></div>
<ul>
<li><strong>Type</strong>: <code>boolean</code></li>
<li><strong>Required</strong>: <code>No</code></li>
<li><strong>User Property</strong>: <code>com.graphql_java_generator.mavenplugin.generateJPAAnnotation</code></li>
<li><strong>Default</strong>: <code>false</code></li></ul><hr /></section><a id="ignoredSpringMappings"></a><section>
<h3>&lt;ignoredSpringMappings&gt;</h3><a id="a.3CignoredSpringMappings.3E"></a>
<div><p>This parameter marks a list of GraphQL mappings as ignored, so that they are not generated by the plugin. These ignored mappings can then be defined by the specific implementation.</p>
<p>The other way to it is to create a spring GraphQL Controller, that overrides the controller generated by the plugin. But this may lead to this error: <code>Ambiguous mapping. Cannot map 'xxxController' method [...] to 'Type.field': there is already 'yyy' bean method [...] mapped.</code></p>
<p>The parameter may contain:</p>
<ul>
 <li>The '*' character: this would mark all controllers and DataFetchersDeleagate to be ignored. That is: none would be generated, and it's up to the specific implementation to manage them. In this mode, you still benefit of the POJO generation, the type wiring, the custom scalars mapping...</li>
 <li>A list of:</li>
 <ul>
  <li>GraphQL type name: The full controller class for this type is ignored, and won't be generated</li>
  <li>GraphQL type's field name: The method in the controller of this type, for this field, is ignored, and won't be generated. The field must be written like this: <code>{type name}.{field name}</code></li>
 </ul>
</ul>
<p>The accepted separators for the values are: comma, space, carriage return, end of line, space, tabulation. At least one separator must exist between two values in the list. Here is a sample:</p>
<pre>
         <ignoredspringmappings>Type1, Type2.field1
         	Type3
         	Type4.field2
         </ignoredspringmappings>
</pre>
<p>For field mapping, there must be no separator other than '.' between the type name and the field name. For instance, the following type declaration are invalid: 'type .field', 'type. field'</p>
<p>To implement the ignored mappings, you'll have to follow the [spring-graphql documentation](https://docs.spring.io/spring-graphql/reference/controllers.html).</p></div>
<ul>
<li><strong>Type</strong>: <code>java.lang.String</code></li>
<li><strong>Required</strong>: <code>No</code></li>
<li><strong>User Property</strong>: <code>com.graphql_java_generator.mavenplugin.ignoredSpringMappings</code></li></ul><hr /></section><a id="inputPrefix"></a><section>
<h3>&lt;inputPrefix&gt;</h3><a id="a.3CinputPrefix.3E"></a>
<div>An optional prefix to add to the classnames of the generated java classes for GraphQL input objects. The prefix is added at the beginning of the java classname, and must be compatible with java naming rules (no space, dot, comma, etc.)</div>
<ul>
<li><strong>Type</strong>: <code>java.lang.String</code></li>
<li><strong>Required</strong>: <code>No</code></li>
<li><strong>User Property</strong>: <code>com.graphql_java_generator.mavenplugin.inputPrefix</code></li></ul><hr /></section><a id="inputSuffix"></a><section>
<h3>&lt;inputSuffix&gt;</h3><a id="a.3CinputSuffix.3E"></a>
<div>An optional suffix to add to the classnames of the generated java classes for GraphQL input objects. The suffix is added at the end of the java classname, and must be compatible with java naming rules (no space, dot, comma, etc.)</div>
<ul>
<li><strong>Type</strong>: <code>java.lang.String</code></li>
<li><strong>Required</strong>: <code>No</code></li>
<li><strong>User Property</strong>: <code>com.graphql_java_generator.mavenplugin.javaClassSuffix</code></li></ul><hr /></section><a id="interfacePrefix"></a><section>
<h3>&lt;interfacePrefix&gt;</h3><a id="a.3CinterfacePrefix.3E"></a>
<div>An optional prefix to add to the classnames of the generated java classes for GraphQL interfaces. The prefix is added at the beginning of the java classname, and must be compatible with java naming rules (no space, dot, comma, etc.)</div>
<ul>
<li><strong>Type</strong>: <code>java.lang.String</code></li>
<li><strong>Required</strong>: <code>No</code></li>
<li><strong>User Property</strong>: <code>com.graphql_java_generator.mavenplugin.interfacePrefix</code></li></ul><hr /></section><a id="interfaceSuffix"></a><section>
<h3>&lt;interfaceSuffix&gt;</h3><a id="a.3CinterfaceSuffix.3E"></a>
<div>An optional suffix to add to the classnames of the generated java classes for GraphQL interfaces. The suffix is added at the end of the java classname, and must be compatible with java naming rules (no space, dot, comma, etc.)</div>
<ul>
<li><strong>Type</strong>: <code>java.lang.String</code></li>
<li><strong>Required</strong>: <code>No</code></li>
<li><strong>User Property</strong>: <code>com.graphql_java_generator.mavenplugin.interfaceSuffix</code></li></ul><hr /></section><a id="javaTypeForIDType"></a><section>
<h3>&lt;javaTypeForIDType&gt;</h3><a id="a.3CjavaTypeForIDType.3E"></a>
<div><p>The <i>javaTypeForIDType</i> is the java class that is used in the generated code for GraphQL fields that are of the GraphQL ID type. The default value is <i>java.util.UUID</i>. Valid values are: java.lang.String, java.lang.Long and java.util.UUID.</p>
<p>This parameter is only valid for the server mode. When generating the client code, the ID is always generated as a String type, as recommended in the GraphQL doc.</p>
<p>In other words: when in server mode and <i>javaTypeForIDType</i> is not set, all GraphQL ID fields are UUID attributes in java. When in server mode and <i>javaTypeForIDType</i> is set to the X type, all GraphQL ID fields are X attributes in java.</p>
<p>Note: you can override this, by using the schema personalization capability. For more information, please have a look at the <a href="https://github.com/graphql-java-generator/graphql-maven-plugin-project/wiki/usage_schema_personalization">Schema Personalization doc page</a>.</p></div>
<ul>
<li><strong>Type</strong>: <code>java.lang.String</code></li>
<li><strong>Required</strong>: <code>No</code></li>
<li><strong>User Property</strong>: <code>com.graphql_java_generator.mavenplugin.javaTypeForIDType</code></li>
<li><strong>Default</strong>: <code>java.util.UUID</code></li></ul><hr /></section><a id="jsonGraphqlSchemaFilename"></a><section>
<h3>&lt;jsonGraphqlSchemaFilename&gt;</h3><a id="a.3CjsonGraphqlSchemaFilename.3E"></a>
<div>No description.</div>
<ul>
<li><strong>Type</strong>: <code>java.lang.String</code></li>
<li><strong>Required</strong>: <code>No</code></li>
<li><strong>User Property</strong>: <code>com.graphql_java_generator.mavenplugin.jsonGraphqlSchemaFilename</code></li></ul><hr /></section><a id="maxTokens"></a><section>
<h3>&lt;maxTokens&gt;</h3><a id="a.3CmaxTokens.3E"></a>
<div><i>(Useless, since 1.18.7)</i>Defines the options that maximum number of tokens that the GraphQL schema parser may read. The default value is Integer.MAX_VALUE (=2147483647). If the schema contains more than <i>maxTokens</i>, the build will fail with an error.</div>
<ul>
<li><strong>Type</strong>: <code>java.lang.Integer</code></li>
<li><strong>Required</strong>: <code>No</code></li>
<li><strong>User Property</strong>: <code>com.graphql_java_generator.mavenplugin.maxTokens</code></li>
<li><strong>Default</strong>: <code>2147483647</code></li></ul><hr /></section><a id="mode"></a><section>
<h3>&lt;mode&gt;</h3><a id="a.3Cmode.3E"></a>
<div>The generation mode: either <i>client</i> or <i>server</i>. Choose client to generate the code which can query a graphql server or server to generate a code for the server side.</div>
<ul>
<li><strong>Type</strong>: <code>com.graphql_java_generator.plugin.conf.PluginMode</code></li>
<li><strong>Required</strong>: <code>No</code></li>
<li><strong>User Property</strong>: <code>com.graphql_java_generator.mavenplugin.mode</code></li>
<li><strong>Default</strong>: <code>client</code></li></ul><hr /></section><a id="packageName"></a><section>
<h3>&lt;packageName&gt;</h3><a id="a.3CpackageName.3E"></a>
<div>The package name that will contain the generated classes</div>
<ul>
<li><strong>Type</strong>: <code>java.lang.String</code></li>
<li><strong>Required</strong>: <code>No</code></li>
<li><strong>User Property</strong>: <code>com.graphql_java_generator.mavenplugin.packageName</code></li>
<li><strong>Default</strong>: <code>com.generated.graphql</code></li></ul><hr /></section><a id="projectBuildDir"></a><section>
<h3>&lt;projectBuildDir&gt;</h3><a id="a.3CprojectBuildDir.3E"></a>
<div>No description.</div>
<ul>
<li><strong>Type</strong>: <code>java.io.File</code></li>
<li><strong>Required</strong>: <code>No</code></li>
<li><strong>Default</strong>: <code>${project.build.directory}</code></li></ul><hr /></section><a id="queryMutationExecutionProtocol"></a><section>
<h3>&lt;queryMutationExecutionProtocol&gt;</h3><a id="a.3CqueryMutationExecutionProtocol.3E"></a>
<div>(since 2.0RC1) The <code>com.graphql_java_generator.plugin.conf.QueryMutationExecutionProtocol</code><!-- no javadoc sites associated --> to use for GraphQL queries and mutations (not subscriptions). The allowed values are: http and webSocket.
<br />
 The default value is http.</div>
<ul>
<li><strong>Type</strong>: <code>com.graphql_java_generator.plugin.conf.QueryMutationExecutionProtocol</code></li>
<li><strong>Required</strong>: <code>No</code></li>
<li><strong>User Property</strong>: <code>com.graphql_java_generator.mavenplugin.queryMutationExecutionProtocol</code></li>
<li><strong>Default</strong>: <code>http</code></li></ul><hr /></section><a id="scanBasePackages"></a><section>
<h3>&lt;scanBasePackages&gt;</h3><a id="a.3CscanBasePackages.3E"></a>
<div><p>(only for server mode) A comma separated list of package names, <b>without</b> double quotes, that will also be parsed by Spring, to discover Spring beans, Spring repositories and JPA entities when the server starts. You should use this parameter only for packages that are not subpackage of the package defined in the _packageName_ parameter and not subpackage of <i>com.graphql_java_generator</i></p>
<p>This allows for instance, to set <i>packageName</i> to <i>your.app.package.graphql</i>, and to define your Spring beans, like the <a href="https://graphql-maven-plugin-project.graphql-java-generator.com/server.html">DataFetcherDelegates</a> or your Spring data repositories in any other folder, by setting for instance scanBasePackages to <i>your.app.package.impl, your.app.package.graphql</i>, or just <i>your.app.package</i></p></div>
<ul>
<li><strong>Type</strong>: <code>java.lang.String</code></li>
<li><strong>Required</strong>: <code>No</code></li>
<li><strong>User Property</strong>: <code>com.graphql_java_generator.mavenplugin.scanBasePackages</code></li>
<li><strong>Default</strong>: <code>null</code></li></ul><hr /></section><a id="schemaFileFolder"></a><section>
<h3>&lt;schemaFileFolder&gt;</h3><a id="a.3CschemaFileFolder.3E"></a>
<div><p>The folder which contains the GraphQL schema file(s) , typically <code>/src/main/resources</code> of the current project. That's where the GraphQL schema(s) are expected to be: in this folder, or one of these subfolders. If the <code>jsonSchemaFilename</code> is set, then this parameter controls where this json schema file is.</p>
<p><u>Caution:</u> this default value for this folder is <code>/src/main/resources</code>, for compatibility with first versions of this plugin. It's different from the spring-graphql default one, which is <i>/src/main/resources/graphql</i></p></div>
<ul>
<li><strong>Type</strong>: <code>java.io.File</code></li>
<li><strong>Required</strong>: <code>No</code></li>
<li><strong>User Property</strong>: <code>com.graphql_java_generator.mavenplugin.schemaFileFolder</code></li>
<li><strong>Default</strong>: <code>src/main/resources</code></li></ul><hr /></section><a id="schemaFilePattern"></a><section>
<h3>&lt;schemaFilePattern&gt;</h3><a id="a.3CschemaFilePattern.3E"></a>
<div><p>The pattern to find the graphql schema file(s). The default value is "/*.graphqls" meaning that the maven plugin will search all graphqls files in the "/src/main/resources" folder (please check also the <i>schemaFileFolder</i> plugin parameter).</p>
<p>You can put the star (*) joker in the filename, to retrieve several files at ones, for instance <i>/myschema*.graphqls</i> will retrieve the <i>/src/main/resources/myschema.graphqls</i> and <i>/src/main/resources/myschema_extend.graphqls</i> files.</p>
<p></p></div>
<ul>
<li><strong>Type</strong>: <code>java.lang.String</code></li>
<li><strong>Required</strong>: <code>No</code></li>
<li><strong>User Property</strong>: <code>com.graphql_java_generator.mavenplugin.schemaFilePattern</code></li>
<li><strong>Default</strong>: <code>*.graphqls</code></li></ul><hr /></section><a id="schemaPersonalizationFile"></a><section>
<h3>&lt;schemaPersonalizationFile&gt;</h3><a id="a.3CschemaPersonalizationFile.3E"></a>
<div><p>schemaPersonalizationFile is the file name where the GraphQL maven plugin will find personalization that it must apply before generating the code. Since the 2.2 release, it is available for both client and server. Before, it applies to the <b>server</b> mode only.</p>
<p></p>
<p>This allows to:</p>
<ul>
 <li>Add or modify fields</li>
 <li>Add interface and annotation to classes (GraphQL types, input types, interfaces, unions and enums) or fields.</li>
</ul>
<p></p>
<p>See <a href="https://github.com/graphql-java-generator/graphql-maven-plugin-project/wiki/usage_schema_personalization">the doc on the project's wiki</a> for more details.</p></div>
<ul>
<li><strong>Type</strong>: <code>java.lang.String</code></li>
<li><strong>Required</strong>: <code>No</code></li>
<li><strong>User Property</strong>: <code>com.graphql_java_generator.mavenplugin.schemaPersonalizationFile</code></li>
<li><strong>Default</strong>: <code>null</code></li></ul><hr /></section><a id="separateUtilityClasses"></a><section>
<h3>&lt;separateUtilityClasses&gt;</h3><a id="a.3CseparateUtilityClasses.3E"></a>
<div><p>Indicates whether the utility classes (that is: the classes that are not match an item in the GraphQL schema) are generated in the same package than the classes that matches the GraphQL schema.</p>
<p>The classes that map the GraphQL schema (type, input type, interfaces, unions...) are <b>generated</b> in the package defined in the <i>packageName</i> plugin parameter, then:</p>
<ul>
 <li>If false <i>(default for versions 1.x)</i>, the utility classes are generated in the the same package</li>
 <li>If true <i>(default for version 2.0 and after)</i>, the utility classes are generated in the <i>util</i> subpackage of this package</li>
</ul></div>
<ul>
<li><strong>Type</strong>: <code>boolean</code></li>
<li><strong>Required</strong>: <code>No</code></li>
<li><strong>User Property</strong>: <code>com.graphql_java_generator.mavenplugin.separateUtilityClasses</code></li>
<li><strong>Default</strong>: <code>true</code></li></ul><hr /></section><a id="skipGenerationIfSchemaHasNotChanged"></a><section>
<h3>&lt;skipGenerationIfSchemaHasNotChanged&gt;</h3><a id="a.3CskipGenerationIfSchemaHasNotChanged.3E"></a>
<div><p>This parameter is now <b><i>deprecated</i></b>: it's value used in the plugin is always true, that is: if the generated sources or resources are older than the GraphQL schema file(s), then there is no source or resource generation. In clear, the source and resource generation is executed only if the provided input (GraphQL schema...) has been updated since the last plugin execution.</p></div>
<ul>
<li><strong>Type</strong>: <code>boolean</code></li>
<li><strong>Required</strong>: <code>No</code></li>
<li><strong>User Property</strong>: <code>com.graphql_java_generator.mavenplugin.skipGenerationIfSchemaHasNotChanged</code></li>
<li><strong>Default</strong>: <code>true</code></li></ul><hr /></section><a id="sourceEncoding"></a><section>
<h3>&lt;sourceEncoding&gt;</h3><a id="a.3CsourceEncoding.3E"></a>
<div>The encoding charset for the generated source files</div>
<ul>
<li><strong>Type</strong>: <code>java.lang.String</code></li>
<li><strong>Required</strong>: <code>No</code></li>
<li><strong>User Property</strong>: <code>com.graphql_java_generator.mavenplugin.sourceEncoding</code></li>
<li><strong>Default</strong>: <code>UTF-8</code></li></ul><hr /></section><a id="springBeanSuffix"></a><section>
<h3>&lt;springBeanSuffix&gt;</h3><a id="a.3CspringBeanSuffix.3E"></a>
<div>Retrieves the suffix that will be applied to the name of the Spring Beans that are generated for this schema. It's mandatory if you' using a Spring app and have more than one GraphQL schemas. The default value is an empty String.</div>
<ul>
<li><strong>Type</strong>: <code>java.lang.String</code></li>
<li><strong>Required</strong>: <code>No</code></li>
<li><strong>User Property</strong>: <code>com.graphql_java_generator.mavenplugin.springBeanSuffix</code></li></ul><hr /></section><a id="targetResourceFolder"></a><section>
<h3>&lt;targetResourceFolder&gt;</h3><a id="a.3CtargetResourceFolder.3E"></a>
<div>The folder where resources will be generated</div>
<ul>
<li><strong>Type</strong>: <code>java.io.File</code></li>
<li><strong>Required</strong>: <code>No</code></li>
<li><strong>User Property</strong>: <code>com.graphql_java_generator.mavenplugin.targetResourceFolder</code></li>
<li><strong>Default</strong>: <code>${project.build.directory}/generated-resources/graphql-maven-plugin</code></li></ul><hr /></section><a id="targetSchemaSubFolder"></a><section>
<h3>&lt;targetSchemaSubFolder&gt;</h3><a id="a.3CtargetSchemaSubFolder.3E"></a>
<div><p>Defines the folder in the classpath that will contain the GraphQL schema, as needed by spring-graphql. The default is the default for spring-graphql, that is: graphql.</p>
<p>Note: If you change this plugin parameter, you must then also define the spring property spring.graphql.schema.location to "classpath*:yourGraphQLSchemaFolder/, in you application.properties or application.yml project file.</p> * 
<p>Since 3.0.x</p> * 
<p>Mandatory if you're using JPMS (java modules), as the default folder is /graphql, which triggers a conflict with the graphql package exposed by graphql-java</p></div>
<ul>
<li><strong>Type</strong>: <code>java.lang.String</code></li>
<li><strong>Required</strong>: <code>No</code></li>
<li><strong>User Property</strong>: <code>com.graphql_java_generator.mavenplugin.targetSchemaSubFolder</code></li>
<li><strong>Default</strong>: <code>graphql</code></li></ul><hr /></section><a id="targetSourceFolder"></a><section>
<h3>&lt;targetSourceFolder&gt;</h3><a id="a.3CtargetSourceFolder.3E"></a>
<div><p>The folder where source code for the generated classes will be generated</p>
<p>The default value is $</p></div>
<ul>
<li><strong>Type</strong>: <code>java.io.File</code></li>
<li><strong>Required</strong>: <code>No</code></li>
<li><strong>User Property</strong>: <code>com.graphql_java_generator.mavenplugin.targetSourceFolder</code></li>
<li><strong>Default</strong>: <code>${project.build.directory}/generated-sources/graphql-maven-plugin</code></li></ul><hr /></section><a id="templates"></a><section>
<h3>&lt;templates&gt;</h3><a id="a.3Ctemplates.3E"></a>
<div><p>Map of the code templates to be used: this allows to override the default templates, and control exactly what code is generated by the plugin.</p>
<p>You can override any of the Velocity templates of the project. The list of templates is defined in the enum CodeTemplate, that you can <a href="https://github.com/graphql-java-generator/graphql-maven-plugin-project/blob/master/graphql-maven-plugin-logic/src/main/java/com/graphql_java_generator/plugin/CodeTemplate.java">check here</a>.</p>
<p>You can find a sample in the <a href="https://github.com/graphql-java-generator/graphql-maven-plugin-project/blob/master/graphql-maven-plugin-samples/graphql-maven-plugin-samples-CustomTemplates-client/pom.xml">CustomTemplates client sample</a>.</p>
<p><b>Important notice:</b> Please note that the default templates may change in the future. And some of these modifications would need to be reported into the custom templates. We'll try to better expose a stable public API in the future.</p></div>
<ul>
<li><strong>Type</strong>: <code>java.util.Map&lt;java.lang.String, java.lang.String&gt;</code></li>
<li><strong>Required</strong>: <code>No</code></li>
<li><strong>User Property</strong>: <code>com.graphql_java_generator.mavenplugin.templates</code></li></ul><hr /></section><a id="typePrefix"></a><section>
<h3>&lt;typePrefix&gt;</h3><a id="a.3CtypePrefix.3E"></a>
<div>An optional prefix to add to the classnames of the generated java classes for GraphQL types. The prefix is added at the beginning of the java classname, and must be compatible with java naming rules (no space, dot, comma, etc.)</div>
<ul>
<li><strong>Type</strong>: <code>java.lang.String</code></li>
<li><strong>Required</strong>: <code>No</code></li>
<li><strong>User Property</strong>: <code>com.graphql_java_generator.mavenplugin.typePrefix</code></li></ul><hr /></section><a id="typeSuffix"></a><section>
<h3>&lt;typeSuffix&gt;</h3><a id="a.3CtypeSuffix.3E"></a>
<div>An optional suffix to add to the classnames of the generated java classes for GraphQL types. The suffix is added at the end of the java classname, and must be compatible with java naming rules (no space, dot, comma, etc.)</div>
<ul>
<li><strong>Type</strong>: <code>java.lang.String</code></li>
<li><strong>Required</strong>: <code>No</code></li>
<li><strong>User Property</strong>: <code>com.graphql_java_generator.mavenplugin.typeSuffix</code></li></ul><hr /></section><a id="unionPrefix"></a><section>
<h3>&lt;unionPrefix&gt;</h3><a id="a.3CunionPrefix.3E"></a>
<div>An optional prefix to add to the classnames of the generated java classes for GraphQL unions. The prefix is added at the beginning of the java classname, and must be compatible with java naming rules (no space, dot, comma, etc.)</div>
<ul>
<li><strong>Type</strong>: <code>java.lang.String</code></li>
<li><strong>Required</strong>: <code>No</code></li>
<li><strong>User Property</strong>: <code>com.graphql_java_generator.mavenplugin.unionPrefix</code></li></ul><hr /></section><a id="unionSuffix"></a><section>
<h3>&lt;unionSuffix&gt;</h3><a id="a.3CunionSuffix.3E"></a>
<div>An optional suffix to add to the classnames of the generated java classes for GraphQL unions. The suffix is added at the end of the java classname, and must be compatible with java naming rules (no space, dot, comma, etc.)</div>
<ul>
<li><strong>Type</strong>: <code>java.lang.String</code></li>
<li><strong>Required</strong>: <code>No</code></li>
<li><strong>User Property</strong>: <code>com.graphql_java_generator.mavenplugin.unionSuffix</code></li></ul><hr /></section><a id="useJakartaEE9"></a><section>
<h3>&lt;useJakartaEE9&gt;</h3><a id="a.3CuseJakartaEE9.3E"></a>
<div><p>(since 2.0RC1) If false, it uses jakarta EE8 imports (that begins by javax.). If true, it uses jakarta EE8 imports (that begins by jakarta.).</p>
<p>(since 3.0) The parameter is ignored. Its value is always true.</p></div>
<ul>
<li><strong>Type</strong>: <code>boolean</code></li>
<li><strong>Required</strong>: <code>No</code></li>
<li><strong>User Property</strong>: <code>com.graphql_java_generator.mavenplugin.useJakartaEE9</code></li>
<li><strong>Default</strong>: <code>true</code></li></ul></section></section></section>
        </main>
      </div>
    </div>
    <hr/>
    <footer>
      <div class="container-fluid">
        <div class="row-fluid">
            <p>&#169;      2025
</p>
        </div>
      </div>
    </footer>
<script>
	if(anchors) {
	  anchors.add();
	}
</script>
  </body>
</html>
