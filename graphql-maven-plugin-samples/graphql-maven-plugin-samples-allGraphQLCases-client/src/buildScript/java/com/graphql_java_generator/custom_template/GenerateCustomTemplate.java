package com.graphql_java_generator.custom_template;

import java.io.IOException;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.List;
import java.util.Properties;
import java.util.SortedSet;
import java.util.TreeSet;

/**
 * This class generates a custom template, bases on the `client_query_mutation_type.vm.java` one, to check that custom
 * templates are properly managed, when provided in an external tool. The reason of having this code is to automatically
 * report any change done in the original template into the custom template, to avoid strange errors, like this
 * one:<br/>
 * <ul>
 * <li>One changes the original template, but forget to report this change into the custom template</li>
 * <li>The generated code doesn't contain the change done in the original template, as it uses the unchanged custom
 * template</li>
 * </ul>
 * This template is tested in the {@link com.graphql_java_generator.customtemplates.ValidateCustomQueryIT} of the
 * graphql-maven-plugin-samples-allGraphQLCases-client maven module.<br/>
 * <b>Important note:</b> This class is executed by the exec-maven-plugin of the current maven project. It is not
 * executed in the gradle build. This has this consequences:
 * <ul>
 * <li>Any change in this class must be tested by a maven build</li>
 * <li>If any change is done on a template in the plugin-logic module, the Maven build must be executed before the
 * gradle build (this is quite logical and automatic, as this module doesn't exist in the Gradle build: the Gradle build
 * just depends on it)</li>
 * <li>The generated file replaces the previous custom template, in the src\main\resources\templates\resttemplate of
 * this project, and will be available as a standard resource, in git (for instance, for the Gradle build)</li>
 * </ul>
 * 
 * @author etienne-sf
 */
public class GenerateCustomTemplate implements Runnable {

	/** True to activate debug logs */
	boolean debug = false;

	// Paths (relative to the project basedir folder)
	private static final String SOURCE_PATH = "/target2/graphql-maven-plugin-logic.templates/templates/";
	private static final String TARGET_PATH = "src/graphqls/customtemplates/";
	private static final List<List<String>> TEMPLATES = List.of(//
			// list(source name, target name). Needed, as some custolm templates have different names than the original ones
			List.of("client_subscription_type.vm.java", "client_subscription_type.vm.java"), //
			List.of("client_subscription_executor.vm.java", "custom_client_subscription_executor.vm.java"));

	// Encoding
	private static final Charset ENCODING = StandardCharsets.UTF_8;

	// Search the first line starting with this string
	// private static final String INSERTION_MARKER = "public class ";
	private static final String INSERTION_MARKER = "public class ";

	/** The properties set into the project's pom(s) */
	final Properties projectProperties;

	/** The system properties available to maven */
	final Properties systemProperties;

	/** Lines to insert at the start of the file */
	private static final List<String> LINES_TO_INSERT_AT_THE_BEGINING = List.of(//
			"##", //
			"## This template is a copy/paste of the original template, with this only modification:", //
			"##  - Add of a boolean field: thisIsADummyFieldToCheckThatThisTemplateIsUsed. It is checked in the IT test, ", //
			"##    to check that the custom templates is actually used.", //
			"## It has been generated by the GenerateCustomTemplate class, in the src/buildScript of the current project, from the original template", //
			"##", //
			"##", //
			"##"//
	);
	/** Lines to insert after the line starting with INSERTION_MARKER */
	private static final List<String> LINES_TO_INSERT_AFTER_INSERTION_MARKER = List.of(//
			"",
			"	/** The field below is the only change from the original template. It is here only to check that this template is actually used */ ",
			"	public boolean thisIsADummyFieldToCheckThatThisTemplateIsUsed = true;" //
	);

	public GenerateCustomTemplate(Properties projectProperties, Properties systemProperties) {
		this.projectProperties = projectProperties;
		this.systemProperties = systemProperties;

		if (debug) {
			System.out.println("----------------------------------");
			System.out.println("System properties:");
			displayProperties(systemProperties);
			System.out.println("----------------------------------");
			System.out.println("Project properties:");
			displayProperties(projectProperties);
		}
	}

	private void displayProperties(Properties props) {
		SortedSet<String> set = new TreeSet<>(props.stringPropertyNames());
		for (String key : set) {
			System.out.println("Property: " + key + "=" + props.getProperty(key));
		}
	}

	@Override
	public void run() {
		// System.out.println("project.basedir: " + projectProperties.getProperty("project.basedir"));
		// System.out.println("SOURCE_PATH=" + getSourcePath().normalize());
		// System.out.println("TARGET_PATH=" + getTargetPath().normalize());

		for (List<String> template : TEMPLATES) {
			try {
				String result = processFile(getSourcePath(template.get(0)), ENCODING);
				writeOutput(result, getTargetPath(template.get(1)), ENCODING);
			} catch (Exception e) {
				throw new RuntimeException(
						"Error generating the " + template.get(1) + " custom template file: " + e.getMessage(), e);
			}
		}
	}

	private Path getSourcePath(String template) {
		String path = projectProperties.getProperty("project.basedir") + "/" + SOURCE_PATH + template;
		return Paths.get(path);
	}

	private Path getTargetPath(String template) {
		return Paths.get(projectProperties.getProperty("project.basedir") + "/" + TARGET_PATH + template);
	}

	/**
	 * Reads the file, finds the line starting with INSERTION_MARKER, and inserts the given lines right after.
	 * 
	 * @param source
	 *            the path to the input file
	 * @param encoding
	 *            the character set to use
	 * @return the full modified text as a single String
	 * @throws IOException
	 *             if reading fails
	 * @throws IllegalStateException
	 *             if the marker line is not found
	 */
	private static String processFile(Path source, Charset encoding) throws IOException {
		if (!Files.exists(source)) {
			throw new IllegalStateException("Source file not found: " + source.toAbsolutePath());
		}

		// Read all lines to preserve original line breaks style (\n or \r\n)
		// We'll normalize to system line separator when writing.
		List<String> lines = Files.readAllLines(source, encoding);

		int insertionIndex = -1;
		for (int i = 0; i < lines.size(); i++) {
			String line = lines.get(i);
			if (line.startsWith(INSERTION_MARKER)) {
				insertionIndex = i + 1; // insert after this line
				break;
			}
		}

		if (insertionIndex == -1) {
			throw new IllegalStateException(
					"No line starting with '" + INSERTION_MARKER + "' was found in: " + source.toAbsolutePath());
		}

		// Build the output with inserted lines
		StringBuilder sb = new StringBuilder();
		String sep = System.lineSeparator();

		// Insertion of LINES_TO_INSERT_AT_THE_BEGINING
		for (String toInsert : LINES_TO_INSERT_AT_THE_BEGINING) {
			sb.append(toInsert).append(sep);
		}

		// Lines before insertion point
		for (int i = 0; i < insertionIndex; i++) {
			sb.append(lines.get(i)).append(sep);
		}

		// Insert requested lines
		for (String toInsert : LINES_TO_INSERT_AFTER_INSERTION_MARKER) {
			sb.append(toInsert).append(sep);
		}

		// Remaining lines
		for (int i = insertionIndex; i < lines.size(); i++) {
			sb.append(lines.get(i));
			if (i < lines.size() - 1) {
				sb.append(sep);
			}
		}

		return sb.toString();
	}

	/**
	 * Writes the given content to the target file, creating parent directories if needed.
	 */
	private static void writeOutput(String content, Path target, Charset encoding) throws IOException {
		Path parent = target.getParent();
		if (parent != null && !Files.exists(parent)) {
			Files.createDirectories(parent);
		}
		Files.writeString(target, content, encoding);
	}

}
