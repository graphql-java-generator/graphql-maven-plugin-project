// Generated by delombok at Mon Dec 22 16:05:30 CET 2025
/**
 * 
 */
package com.graphql_java_generator.plugin.language.impl;

import java.util.ArrayList;
import java.util.List;

import com.graphql_java_generator.plugin.DocumentParser;
import com.graphql_java_generator.plugin.generate_code.GenerateCodeDocumentParser;
import com.graphql_java_generator.plugin.language.AppliedDirective;
import com.graphql_java_generator.plugin.language.DataFetcher;
import com.graphql_java_generator.plugin.language.Description;
import com.graphql_java_generator.plugin.language.Field;
import com.graphql_java_generator.plugin.language.FieldTypeAST;
import com.graphql_java_generator.plugin.language.Relation;
import com.graphql_java_generator.plugin.language.Type;
import com.graphql_java_generator.util.GraphqlUtils;

import graphql.language.Comment;
import graphql.language.Value;

/**
 * @author etienne-sf
 */
public class FieldImpl implements Field {
	/**
	 * The {@link GenerateCodeDocumentParser} instance, which will allow to get the {@link Type} of the field, from its
	 * typeName, after the whole parsing is finished
	 */
	final DocumentParser documentParser;
	/**
	 * The name of the field
	 */
	private String name;
	/**
	 * Returns the GraphQL type information, as it has been read from the AST. See {@link FieldTypeAST} for more
	 * information, here.
	 */
	private FieldTypeAST fieldTypeAST;
	// Allows the default value to be used with the Lombok @Builder annotation on the class
	/**
	 * Is this field an identifier? <BR/>
	 * By default, a field is an identifier if its GraphQL type is "ID". But this may be overridden with the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/schema_personalization.html">Schema
	 * Personalization</A>
	 */
	Boolean id;
	/**
	 * The {@link Type} which contains this field
	 */
	private Type owningType;
	// Allows the default value to be used with the Lombok @Builder annotation on the class
	/**
	 * All fields in an object may have parameters. A parameter is actually a field.
	 */
	private List<Field> inputParameters;
	/**
	 * The data fetcher associated to this field, or null if this field has no data fetcher
	 */
	DataFetcher dataFetcher;
	/**
	 * Contains the default value, as defined in the GraphQL schema. For enums, it contains the label of the enum, not
	 * the value of the enum.<BR/>
	 * We store the graphql.language.Value as we receive it. We may not have parsed the relevant Object to check its
	 * field, and obviously, we can't instanciate any object or enum yet, as we dont't even generated any code.
	 */
	private Value<?> defaultValue;
	/**
	 * Contains the description of the relation that this field holds
	 */
	private Relation relation;
	/**
	 * The Java annotation to add to this type, ready to be added by the Velocity template. That is: one annotation per
	 * line, each line starting at the beginning of the line
	 */
	private String annotation;
	/**
	 * All directives that have been defined in the GraphQL schema for this field
	 */
	private List<AppliedDirective> appliedDirectives;
	/**
	 * The comments that have been found before this field, in the provided GraphQL schema
	 */
	private List<String> comments;
	/**
	 * The description of this field, in the provided GraphQL schema
	 */
	private Description description;

	@Override
	public Type getType() {
		return documentParser.getType(getGraphQLTypeSimpleName());
	}

	@Override
	public String getAnnotation() {
		return (annotation == null) ? "" : annotation;
	}

	@Override
	public boolean isId() {
		if (id == null) {
			id = getGraphQLTypeSimpleName().equals("ID");
		}
		return id;
	}

	/**
	 * The annotation setter should be used. Please use the {@link #addAnnotation(String))} instead
	 * 
	 * @param annotation
	 *            The annotation, that will replace the current one
	 */
	@Deprecated
	public void setAnnotation(String annotation) {
		this.annotation = annotation;
	}

	/**
	 * The annotation setter should be added. This method allows to properly manage indentation in the generated source
	 * code
	 * 
	 * @param annotationToAdd
	 *            The annotation, that will be added to the current one
	 */
	public void addAnnotation(String annotationToAdd) {
		if (annotation == null || annotation.contentEquals("")) {
			annotation = annotationToAdd;
		} else {
			// We add this annotation on a next line.
			annotation = annotation + "\n\t" + annotationToAdd;
		}
	}

	/**
	 * The annotation setter should be added. This method allows to properly manage indentation in the generated source
	 * code
	 * 
	 * @param annotationToAdd
	 *            The annotation, that will be added to the current one
	 * @param replace
	 *            if true, any existing annotation is first removed
	 */
	public void addAnnotation(String annotationToAdd, boolean replace) {
		if (replace) {
			annotation = "";
		}
		addAnnotation(annotationToAdd);
	}

	@Override
	public String getPascalCaseName() {
		return GraphqlUtils.graphqlUtils.getPascalCase(getName());
	}

	public void setComments(List<Comment> comments) {
		this.comments = new ArrayList<>(comments.size());
		for (Comment c : comments) {
			this.comments.add(c.getContent());
		}
	}

	@Override
	public String toString() {
		StringBuilder sb = new StringBuilder();
		// Field's name
		sb.append("Field{name:");
		sb.append(getName());
		// Field's type
		sb.append(", type:");
		sb.append(getFieldTypeAST().getGraphQLType());
		// Field's parameters
		sb.append(", params:[");
		boolean appendSeparator = false;
		for (Field param : inputParameters) {
			if (appendSeparator) {
				sb.append(",");
			} else {
				appendSeparator = true;
			}
			sb.append(param.getName()).append(":");
			sb.append(param.getFieldTypeAST().getGraphQLType());
		} // for
		sb.append("]}");
		return sb.toString();
	}

	private static Boolean $default$id() {
		return null;
	}

	private static List<Field> $default$inputParameters() {
		return new ArrayList<>();
	}

	private static DataFetcher $default$dataFetcher() {
		return null;
	}

	private static Value<?> $default$defaultValue() {
		return null;
	}

	private static Relation $default$relation() {
		return null;
	}

	private static String $default$annotation() {
		return "";
	}

	private static List<AppliedDirective> $default$appliedDirectives() {
		return new ArrayList<>();
	}

	private static List<String> $default$comments() {
		return new ArrayList<>();
	}

	/**
	 * Creates a new {@code FieldImpl} instance.
	 *
	 * @param documentParser
	 *            The {@link GenerateCodeDocumentParser} instance, which will allow to get the {@link Type} of the
	 *            field, from its typeName, after the whole parsing is finished
	 * @param name
	 *            The name of the field
	 * @param fieldTypeAST
	 *            Returns the GraphQL type information, as it has been read from the AST. See {@link FieldTypeAST} for
	 *            more information, here.
	 * @param id
	 *            Is this field an identifier? <BR/>
	 *            By default, a field is an identifier if its GraphQL type is "ID". But this may be overridden with the
	 *            <A HREF=
	 *            "https://graphql-maven-plugin-project.graphql-java-generator.com/schema_personalization.html">Schema
	 *            Personalization</A>
	 * @param owningType
	 *            The {@link Type} which contains this field
	 * @param inputParameters
	 *            All fields in an object may have parameters. A parameter is actually a field.
	 * @param dataFetcher
	 *            The data fetcher associated to this field, or null if this field has no data fetcher
	 * @param defaultValue
	 *            Contains the default value, as defined in the GraphQL schema. For enums, it contains the label of the
	 *            enum, not the value of the enum.<BR/>
	 *            We store the graphql.language.Value as we receive it. We may not have parsed the relevant Object to
	 *            check its field, and obviously, we can't instanciate any object or enum yet, as we dont't even
	 *            generated any code.
	 * @param relation
	 *            Contains the description of the relation that this field holds
	 * @param annotation
	 *            The Java annotation to add to this type, ready to be added by the Velocity template. That is: one
	 *            annotation per line, each line starting at the beginning of the line
	 * @param appliedDirectives
	 *            All directives that have been defined in the GraphQL schema for this field
	 * @param comments
	 *            The comments that have been found before this field, in the provided GraphQL schema
	 * @param description
	 *            The description of this field, in the provided GraphQL schema
	 */

	FieldImpl(final DocumentParser documentParser, final String name, final FieldTypeAST fieldTypeAST, final Boolean id,
			final Type owningType, final List<Field> inputParameters, final DataFetcher dataFetcher,
			final Value<?> defaultValue, final Relation relation, final String annotation,
			final List<AppliedDirective> appliedDirectives, final List<String> comments,
			final Description description) {
		this.documentParser = documentParser;
		this.name = name;
		this.fieldTypeAST = fieldTypeAST;
		this.id = id;
		this.owningType = owningType;
		this.inputParameters = inputParameters;
		this.dataFetcher = dataFetcher;
		this.defaultValue = defaultValue;
		this.relation = relation;
		this.annotation = annotation;
		this.appliedDirectives = appliedDirectives;
		this.comments = comments;
		this.description = description;
	}

	public static class FieldImplBuilder {

		private DocumentParser documentParser;

		private String name;

		private FieldTypeAST fieldTypeAST;

		private boolean id$set;

		private Boolean id$value;

		private Type owningType;

		private boolean inputParameters$set;

		private List<Field> inputParameters$value;

		private boolean dataFetcher$set;

		private DataFetcher dataFetcher$value;

		private boolean defaultValue$set;

		private Value<?> defaultValue$value;

		private boolean relation$set;

		private Relation relation$value;

		private boolean annotation$set;

		private String annotation$value;

		private boolean appliedDirectives$set;

		private List<AppliedDirective> appliedDirectives$value;

		private boolean comments$set;

		private List<String> comments$value;

		private Description description;

		FieldImplBuilder() {
		}

		/**
		 * The {@link GenerateCodeDocumentParser} instance, which will allow to get the {@link Type} of the field, from
		 * its typeName, after the whole parsing is finished
		 * 
		 * @return {@code this}.
		 */

		public FieldImpl.FieldImplBuilder documentParser(final DocumentParser documentParser) {
			this.documentParser = documentParser;
			return this;
		}

		/**
		 * The name of the field
		 * 
		 * @return {@code this}.
		 */

		public FieldImpl.FieldImplBuilder name(final String name) {
			this.name = name;
			return this;
		}

		/**
		 * Returns the GraphQL type information, as it has been read from the AST. See {@link FieldTypeAST} for more
		 * information, here.
		 * 
		 * @return {@code this}.
		 */

		public FieldImpl.FieldImplBuilder fieldTypeAST(final FieldTypeAST fieldTypeAST) {
			this.fieldTypeAST = fieldTypeAST;
			return this;
		}

		/**
		 * Is this field an identifier? <BR/>
		 * By default, a field is an identifier if its GraphQL type is "ID". But this may be overridden with the
		 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/schema_personalization.html">Schema
		 * Personalization</A>
		 * 
		 * @return {@code this}.
		 */

		public FieldImpl.FieldImplBuilder id(final Boolean id) {
			this.id$value = id;
			id$set = true;
			return this;
		}

		/**
		 * The {@link Type} which contains this field
		 * 
		 * @return {@code this}.
		 */

		public FieldImpl.FieldImplBuilder owningType(final Type owningType) {
			this.owningType = owningType;
			return this;
		}

		/**
		 * All fields in an object may have parameters. A parameter is actually a field.
		 * 
		 * @return {@code this}.
		 */

		public FieldImpl.FieldImplBuilder inputParameters(final List<Field> inputParameters) {
			this.inputParameters$value = inputParameters;
			inputParameters$set = true;
			return this;
		}

		/**
		 * The data fetcher associated to this field, or null if this field has no data fetcher
		 * 
		 * @return {@code this}.
		 */

		public FieldImpl.FieldImplBuilder dataFetcher(final DataFetcher dataFetcher) {
			this.dataFetcher$value = dataFetcher;
			dataFetcher$set = true;
			return this;
		}

		/**
		 * Contains the default value, as defined in the GraphQL schema. For enums, it contains the label of the enum,
		 * not the value of the enum.<BR/>
		 * We store the graphql.language.Value as we receive it. We may not have parsed the relevant Object to check its
		 * field, and obviously, we can't instanciate any object or enum yet, as we dont't even generated any code.
		 * 
		 * @return {@code this}.
		 */

		public FieldImpl.FieldImplBuilder defaultValue(final Value<?> defaultValue) {
			this.defaultValue$value = defaultValue;
			defaultValue$set = true;
			return this;
		}

		/**
		 * Contains the description of the relation that this field holds
		 * 
		 * @return {@code this}.
		 */

		public FieldImpl.FieldImplBuilder relation(final Relation relation) {
			this.relation$value = relation;
			relation$set = true;
			return this;
		}

		/**
		 * The Java annotation to add to this type, ready to be added by the Velocity template. That is: one annotation
		 * per line, each line starting at the beginning of the line
		 * 
		 * @return {@code this}.
		 */

		public FieldImpl.FieldImplBuilder annotation(final String annotation) {
			this.annotation$value = annotation;
			annotation$set = true;
			return this;
		}

		/**
		 * All directives that have been defined in the GraphQL schema for this field
		 * 
		 * @return {@code this}.
		 */

		public FieldImpl.FieldImplBuilder appliedDirectives(final List<AppliedDirective> appliedDirectives) {
			this.appliedDirectives$value = appliedDirectives;
			appliedDirectives$set = true;
			return this;
		}

		/**
		 * The comments that have been found before this field, in the provided GraphQL schema
		 * 
		 * @return {@code this}.
		 */

		public FieldImpl.FieldImplBuilder comments(final List<String> comments) {
			this.comments$value = comments;
			comments$set = true;
			return this;
		}

		/**
		 * The description of this field, in the provided GraphQL schema
		 * 
		 * @return {@code this}.
		 */

		public FieldImpl.FieldImplBuilder description(final Description description) {
			this.description = description;
			return this;
		}

		public FieldImpl build() {
			Boolean id$value = this.id$value;
			if (!this.id$set) {
				id$value = FieldImpl.$default$id();
			}
			List<Field> inputParameters$value = this.inputParameters$value;
			if (!this.inputParameters$set) {
				inputParameters$value = FieldImpl.$default$inputParameters();
			}
			DataFetcher dataFetcher$value = this.dataFetcher$value;
			if (!this.dataFetcher$set) {
				dataFetcher$value = FieldImpl.$default$dataFetcher();
			}
			Value<?> defaultValue$value = this.defaultValue$value;
			if (!this.defaultValue$set) {
				defaultValue$value = FieldImpl.$default$defaultValue();
			}
			Relation relation$value = this.relation$value;
			if (!this.relation$set) {
				relation$value = FieldImpl.$default$relation();
			}
			String annotation$value = this.annotation$value;
			if (!this.annotation$set) {
				annotation$value = FieldImpl.$default$annotation();
			}
			List<AppliedDirective> appliedDirectives$value = this.appliedDirectives$value;
			if (!this.appliedDirectives$set) {
				appliedDirectives$value = FieldImpl.$default$appliedDirectives();
			}
			List<String> comments$value = this.comments$value;
			if (!this.comments$set) {
				comments$value = FieldImpl.$default$comments();
			}
			return new FieldImpl(this.documentParser, this.name, this.fieldTypeAST, id$value, this.owningType,
					inputParameters$value, dataFetcher$value, defaultValue$value, relation$value, annotation$value,
					appliedDirectives$value, comments$value, this.description);
		}

		@java.lang.Override

		public java.lang.String toString() {
			return "FieldImpl.FieldImplBuilder(documentParser=" + this.documentParser + ", name=" + this.name
					+ ", fieldTypeAST=" + this.fieldTypeAST + ", id$value=" + this.id$value + ", owningType="
					+ this.owningType + ", inputParameters$value=" + this.inputParameters$value + ", dataFetcher$value="
					+ this.dataFetcher$value + ", defaultValue$value=" + this.defaultValue$value + ", relation$value="
					+ this.relation$value + ", annotation$value=" + this.annotation$value + ", appliedDirectives$value="
					+ this.appliedDirectives$value + ", comments$value=" + this.comments$value + ", description="
					+ this.description + ")";
		}
	}

	public static FieldImpl.FieldImplBuilder builder() {
		return new FieldImpl.FieldImplBuilder();
	}

	public FieldImpl.FieldImplBuilder toBuilder() {
		return new FieldImpl.FieldImplBuilder().documentParser(this.documentParser).name(this.name)
				.fieldTypeAST(this.fieldTypeAST).id(this.id).owningType(this.owningType)
				.inputParameters(this.inputParameters).dataFetcher(this.dataFetcher).defaultValue(this.defaultValue)
				.relation(this.relation).annotation(this.annotation).appliedDirectives(this.appliedDirectives)
				.comments(this.comments).description(this.description);
	}

	/**
	 * The {@link GenerateCodeDocumentParser} instance, which will allow to get the {@link Type} of the field, from its
	 * typeName, after the whole parsing is finished
	 */

	public DocumentParser getDocumentParser() {
		return this.documentParser;
	}

	/**
	 * The name of the field
	 */

	@Override
	public String getName() {
		return this.name;
	}

	/**
	 * Returns the GraphQL type information, as it has been read from the AST. See {@link FieldTypeAST} for more
	 * information, here.
	 * 
	 * @return
	 */

	@Override
	public FieldTypeAST getFieldTypeAST() {
		return this.fieldTypeAST;
	}

	/**
	 * Is this field an identifier? <BR/>
	 * By default, a field is an identifier if its GraphQL type is "ID". But this may be overridden with the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/schema_personalization.html">Schema
	 * Personalization</A>
	 */

	public Boolean getId() {
		return this.id;
	}

	/**
	 * The {@link Type} which contains this field
	 */

	@Override
	public Type getOwningType() {
		return this.owningType;
	}

	/**
	 * All fields in an object may have parameters. A parameter is actually a field.
	 */

	@Override
	public List<Field> getInputParameters() {
		return this.inputParameters;
	}

	/**
	 * The data fetcher associated to this field, or null if this field has no data fetcher
	 */

	@Override
	public DataFetcher getDataFetcher() {
		return this.dataFetcher;
	}

	/**
	 * Contains the default value, as defined in the GraphQL schema. For enums, it contains the label of the enum, not
	 * the value of the enum.<BR/>
	 * We store the graphql.language.Value as we receive it. We may not have parsed the relevant Object to check its
	 * field, and obviously, we can't instanciate any object or enum yet, as we dont't even generated any code.
	 */

	@Override
	public Value<?> getDefaultValue() {
		return this.defaultValue;
	}

	/**
	 * Contains the description of the relation that this field holds
	 */

	@Override
	public Relation getRelation() {
		return this.relation;
	}

	/**
	 * All directives that have been defined in the GraphQL schema for this field
	 */

	@Override
	public List<AppliedDirective> getAppliedDirectives() {
		return this.appliedDirectives;
	}

	/**
	 * The comments that have been found before this field, in the provided GraphQL schema
	 */

	@Override
	public List<String> getComments() {
		return this.comments;
	}

	/**
	 * The description of this field, in the provided GraphQL schema
	 */

	@Override
	public Description getDescription() {
		return this.description;
	}

	/**
	 * The name of the field
	 */

	public void setName(final String name) {
		this.name = name;
	}

	/**
	 * Returns the GraphQL type information, as it has been read from the AST. See {@link FieldTypeAST} for more
	 * information, here.
	 */

	public void setFieldTypeAST(final FieldTypeAST fieldTypeAST) {
		this.fieldTypeAST = fieldTypeAST;
	}

	/**
	 * Is this field an identifier? <BR/>
	 * By default, a field is an identifier if its GraphQL type is "ID". But this may be overridden with the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/schema_personalization.html">Schema
	 * Personalization</A>
	 */

	public void setId(final Boolean id) {
		this.id = id;
	}

	/**
	 * The {@link Type} which contains this field
	 */

	public void setOwningType(final Type owningType) {
		this.owningType = owningType;
	}

	/**
	 * All fields in an object may have parameters. A parameter is actually a field.
	 */

	public void setInputParameters(final List<Field> inputParameters) {
		this.inputParameters = inputParameters;
	}

	/**
	 * The data fetcher associated to this field, or null if this field has no data fetcher
	 */

	public void setDataFetcher(final DataFetcher dataFetcher) {
		this.dataFetcher = dataFetcher;
	}

	/**
	 * Contains the default value, as defined in the GraphQL schema. For enums, it contains the label of the enum, not
	 * the value of the enum.<BR/>
	 * We store the graphql.language.Value as we receive it. We may not have parsed the relevant Object to check its
	 * field, and obviously, we can't instanciate any object or enum yet, as we dont't even generated any code.
	 */

	public void setDefaultValue(final Value<?> defaultValue) {
		this.defaultValue = defaultValue;
	}

	/**
	 * Contains the description of the relation that this field holds
	 */

	public void setRelation(final Relation relation) {
		this.relation = relation;
	}

	/**
	 * All directives that have been defined in the GraphQL schema for this field
	 */

	public void setAppliedDirectives(final List<AppliedDirective> appliedDirectives) {
		this.appliedDirectives = appliedDirectives;
	}

	/**
	 * The description of this field, in the provided GraphQL schema
	 */

	public void setDescription(final Description description) {
		this.description = description;
	}

	@java.lang.Override

	public boolean equals(final java.lang.Object o) {
		if (o == this) {
			return true;
		}
		if (!(o instanceof FieldImpl)) {
			return false;
		}
		final FieldImpl other = (FieldImpl) o;
		if (!other.canEqual(this)) {
			return false;
		}
		final java.lang.Object this$id = this.getId();
		final java.lang.Object other$id = other.getId();
		if (this$id == null ? other$id != null : !this$id.equals(other$id)) {
			return false;
		}
		final java.lang.Object this$documentParser = this.getDocumentParser();
		final java.lang.Object other$documentParser = other.getDocumentParser();
		if (this$documentParser == null ? other$documentParser != null
				: !this$documentParser.equals(other$documentParser)) {
			return false;
		}
		final java.lang.Object this$name = this.getName();
		final java.lang.Object other$name = other.getName();
		if (this$name == null ? other$name != null : !this$name.equals(other$name)) {
			return false;
		}
		final java.lang.Object this$fieldTypeAST = this.getFieldTypeAST();
		final java.lang.Object other$fieldTypeAST = other.getFieldTypeAST();
		if (this$fieldTypeAST == null ? other$fieldTypeAST != null : !this$fieldTypeAST.equals(other$fieldTypeAST)) {
			return false;
		}
		final java.lang.Object this$owningType = this.getOwningType();
		final java.lang.Object other$owningType = other.getOwningType();
		if (this$owningType == null ? other$owningType != null : !this$owningType.equals(other$owningType)) {
			return false;
		}
		final java.lang.Object this$inputParameters = this.getInputParameters();
		final java.lang.Object other$inputParameters = other.getInputParameters();
		if (this$inputParameters == null ? other$inputParameters != null
				: !this$inputParameters.equals(other$inputParameters)) {
			return false;
		}
		final java.lang.Object this$dataFetcher = this.getDataFetcher();
		final java.lang.Object other$dataFetcher = other.getDataFetcher();
		if (this$dataFetcher == null ? other$dataFetcher != null : !this$dataFetcher.equals(other$dataFetcher)) {
			return false;
		}
		final java.lang.Object this$defaultValue = this.getDefaultValue();
		final java.lang.Object other$defaultValue = other.getDefaultValue();
		if (this$defaultValue == null ? other$defaultValue != null : !this$defaultValue.equals(other$defaultValue)) {
			return false;
		}
		final java.lang.Object this$relation = this.getRelation();
		final java.lang.Object other$relation = other.getRelation();
		if (this$relation == null ? other$relation != null : !this$relation.equals(other$relation)) {
			return false;
		}
		final java.lang.Object this$annotation = this.getAnnotation();
		final java.lang.Object other$annotation = other.getAnnotation();
		if (this$annotation == null ? other$annotation != null : !this$annotation.equals(other$annotation)) {
			return false;
		}
		final java.lang.Object this$appliedDirectives = this.getAppliedDirectives();
		final java.lang.Object other$appliedDirectives = other.getAppliedDirectives();
		if (this$appliedDirectives == null ? other$appliedDirectives != null
				: !this$appliedDirectives.equals(other$appliedDirectives)) {
			return false;
		}
		final java.lang.Object this$comments = this.getComments();
		final java.lang.Object other$comments = other.getComments();
		if (this$comments == null ? other$comments != null : !this$comments.equals(other$comments)) {
			return false;
		}
		final java.lang.Object this$description = this.getDescription();
		final java.lang.Object other$description = other.getDescription();
		if (this$description == null ? other$description != null : !this$description.equals(other$description)) {
			return false;
		}
		return true;
	}

	protected boolean canEqual(final java.lang.Object other) {
		return other instanceof FieldImpl;
	}

	@java.lang.Override

	public int hashCode() {
		final int PRIME = 59;
		int result = 1;
		final java.lang.Object $id = this.getId();
		result = result * PRIME + ($id == null ? 43 : $id.hashCode());
		final java.lang.Object $documentParser = this.getDocumentParser();
		result = result * PRIME + ($documentParser == null ? 43 : $documentParser.hashCode());
		final java.lang.Object $name = this.getName();
		result = result * PRIME + ($name == null ? 43 : $name.hashCode());
		final java.lang.Object $fieldTypeAST = this.getFieldTypeAST();
		result = result * PRIME + ($fieldTypeAST == null ? 43 : $fieldTypeAST.hashCode());
		final java.lang.Object $owningType = this.getOwningType();
		result = result * PRIME + ($owningType == null ? 43 : $owningType.hashCode());
		final java.lang.Object $inputParameters = this.getInputParameters();
		result = result * PRIME + ($inputParameters == null ? 43 : $inputParameters.hashCode());
		final java.lang.Object $dataFetcher = this.getDataFetcher();
		result = result * PRIME + ($dataFetcher == null ? 43 : $dataFetcher.hashCode());
		final java.lang.Object $defaultValue = this.getDefaultValue();
		result = result * PRIME + ($defaultValue == null ? 43 : $defaultValue.hashCode());
		final java.lang.Object $relation = this.getRelation();
		result = result * PRIME + ($relation == null ? 43 : $relation.hashCode());
		final java.lang.Object $annotation = this.getAnnotation();
		result = result * PRIME + ($annotation == null ? 43 : $annotation.hashCode());
		final java.lang.Object $appliedDirectives = this.getAppliedDirectives();
		result = result * PRIME + ($appliedDirectives == null ? 43 : $appliedDirectives.hashCode());
		final java.lang.Object $comments = this.getComments();
		result = result * PRIME + ($comments == null ? 43 : $comments.hashCode());
		final java.lang.Object $description = this.getDescription();
		result = result * PRIME + ($description == null ? 43 : $description.hashCode());
		return result;
	}
}
