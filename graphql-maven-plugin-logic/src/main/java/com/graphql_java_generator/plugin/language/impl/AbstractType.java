// Generated by delombok at Mon Dec 22 16:05:30 CET 2025
package com.graphql_java_generator.plugin.language.impl;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Objects;
import java.util.Set;
import java.util.TreeSet;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import com.graphql_java_generator.plugin.DocumentParser;
import com.graphql_java_generator.plugin.conf.CommonConfiguration;
import com.graphql_java_generator.plugin.conf.GraphQLConfiguration;
import com.graphql_java_generator.plugin.language.AppliedDirective;
import com.graphql_java_generator.plugin.language.Description;
import com.graphql_java_generator.plugin.language.Field;
import com.graphql_java_generator.plugin.language.Type;
import com.graphql_java_generator.util.GraphqlUtils;
import graphql.language.Comment;


public abstract class AbstractType implements Type {
	/**
	 * The current plugin configuration, which is accessible through an interface that extends
	 * {@link CommonConfiguration}
	 */
	final CommonConfiguration configuration;
	/**
	 * The {@link DocumentParser} that has parsed the schema, and so that contains the whole schema definition
	 */
	final DocumentParser documentParser;
	/**
	 * The name of the object type
	 */
	private String name;
	/**
	 * The list of imports for this object. It's an order Set, so that the generated java file is clean
	 */
	private Set<String> imports = new TreeSet<>();
	/**
	 * The list of imports for this object, that should be used for utility classes, when
	 * {@link GraphQLConfiguration#isSeparateUtilityClasses()} is true. It's an order Set, so that the generated java
	 * file is clean
	 */
	private Set<String> importsForUtilityClasses = new TreeSet<>();
	/**
	 * Tha Java annotation(s) to add to this type, ready to be added by the Velocity template. That is: one annotation
	 * per line, each line starting at the beginning of the line
	 */
	private String annotation;
	/**
	 * All directives that have been defined in the GraphQL schema for this type
	 */
	private List<AppliedDirective> appliedDirectives = new ArrayList<>();
	/**
	 * List of additional interfaces implemented by this object. Items can be added to this list through the schema
	 * personalization capability.<br/>
	 * Interface can be added to types, input types, interfaces, unions and enums.
	 */
	private Set<String> additionalInterfaces = new HashSet<>();
	/**
	 * The comments that have been found before this type, in the provided GraphQL schema
	 */
	private List<String> comments = new ArrayList<>();
	/**
	 * The description of this type, in the provided GraphQL schema
	 */
	private Description description = null;
	/**
	 * The GraphQL type for this type
	 */
	private final GraphQlType graphQlType;

	/**
	 * @param name
	 * @param graphQlType
	 *            The type of object
	 * @param configuration
	 *            The current plugin configuration, which is accessible through an interface that extends
	 *            {@link CommonConfiguration}
	 * @param documentParser
	 *            The {@link DocumentParser} that has parsed the schema, and so that contains the whole schema
	 *            definition
	 */
	public AbstractType(String name, GraphQlType graphQlType, CommonConfiguration configuration, DocumentParser documentParser) {
		this.name = name;
		this.graphQlType = graphQlType;
		this.configuration = configuration;
		this.documentParser = documentParser;
	}

	@Override
	public GraphQlType getGraphQlType() {
		return graphQlType;
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public String getClassSimpleName() {
		return getJavaName();
	}

	@Override
	public String getJavaName() {
		// Optionally add a prefix and/or suffix to the name
		String name = Stream.of(getPrefix(), getName(), getSuffix()).filter(Objects::nonNull).collect(Collectors.joining());
		return GraphqlUtils.graphqlUtils.getJavaName(name);
	}

	protected String getPrefix() {
		return "";
	}

	protected String getSuffix() {
		return "";
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public String getCamelCaseName() {
		return GraphqlUtils.graphqlUtils.getCamelCase(getName());
	}

	@Override
	public String toString() {
		StringBuilder sb = new StringBuilder(name);
		if (getComments() == null) {
			sb.append(", comments=null");
		} else if (getComments().size() > 0) {
			sb.append(", comments=empty");
		} else {
			sb.append(", comments \"");
			sb.append(String.join("\\n", getComments()));
			sb.append("\"");
		}
		return sb.toString();
	}

	@Override
	public String getAnnotation() {
		return (annotation == null) ? "" : annotation;
	}

	/**
	 * The annotation setter should be used. Please use the {@link #addAnnotation(String)} instead
	 * 
	 * @param annotation
	 *            The annotation, that will replace the current one
	 */
	@Deprecated
	public void setAnnotation(String annotation) {
		this.annotation = annotation;
	}

	@Override
	public void addImport(String targetPackageName, String classname) {
		if (!classname.endsWith("." + getJavaName())) {
			// We only import if it's another simple classname
			addImport(imports, targetPackageName, classname);
		}
	}

	@Override
	public void addImportForUtilityClasses(String targetPackageName, String classname) {
		addImport(importsForUtilityClasses, targetPackageName, classname);
	}

	/**
	 * Adds, if necessary the import calculated from the given parameters, into the given set of imports.
	 * 
	 * @param imports
	 *            The set of import, in which the import for the given parameters is to be added
	 * @param targetPackageName
	 *            The package in which is the class that will contain this import
	 * @param classname
	 *            the full classname of the class to import
	 * @return
	 */
	void addImport(Set<String> imports, String targetPackageName, String classname) {
		// For inner class, the classname is "MainClassname$InnerClassname". And the
		// inner class must be imported, even
		// if we are in the same package. So, we replace all $ by dot
		String fullClassname = classname.replace('$', '.');
		int lastDotPos = fullClassname.lastIndexOf('.');
		String packageName = lastDotPos < 0 ? "" : fullClassname.substring(0, lastDotPos);
		String simpleClassName = fullClassname.substring(lastDotPos + 1);
		// No import for primitive types and java.lang
		// And no import if the class is in the same package.
		if (!packageName.isEmpty() && !packageName.equals("java.lang") && !targetPackageName.equals(packageName)) {
			imports.add(packageName + "." + simpleClassName);
		}
	}

	/**
	 * The annotation setter should be added. This method allows to properly manage indentation in the generated source
	 * code
	 * 
	 * @param annotationToAdd
	 *            The annotation, that will be added to the current one
	 */
	@Override
	public void addAnnotation(String annotationToAdd) {
		if (annotation == null || annotation.contentEquals("")) {
			annotation = annotationToAdd;
		} else {
			// We add this annotation on a next line.
			// Add indentation only for fields (not types)
			annotation = annotation + ((this instanceof Field) ? "\n\t\t" : "\n") + annotationToAdd;
		}
	}

	/**
	 * The annotation setter should be added. This method allows to properly manage indentation in the generated source
	 * code
	 * 
	 * @param annotationToAdd
	 *            The annotation, that will be added to the current one
	 * @parma replace if true, any existing annotation is first removed
	 */
	@Override
	public void addAnnotation(String annotationToAdd, boolean replace) {
		if (replace) {
			annotation = "";
		}
		addAnnotation(annotationToAdd);
	}

	public void setComments(List<Comment> comments) {
		this.comments = new ArrayList<>(comments.size());
		for (Comment c : comments) {
			this.comments.add(c.getContent());
		}
	}

	/**
	 * The current plugin configuration, which is accessible through an interface that extends
	 * {@link CommonConfiguration}
	 */
	
	
	public CommonConfiguration getConfiguration() {
		return this.configuration;
	}

	/**
	 * The {@link DocumentParser} that has parsed the schema, and so that contains the whole schema definition
	 */
	
	
	public DocumentParser getDocumentParser() {
		return this.documentParser;
	}

	/**
	 * The name of the object type
	 */
	
	
	public String getName() {
		return this.name;
	}

	/**
	 * The list of imports for this object. It's an order Set, so that the generated java file is clean
	 */
	
	
	public Set<String> getImports() {
		return this.imports;
	}

	/**
	 * The list of imports for this object, that should be used for utility classes, when
	 * {@link GraphQLConfiguration#isSeparateUtilityClasses()} is true. It's an order Set, so that the generated java
	 * file is clean
	 */
	
	
	public Set<String> getImportsForUtilityClasses() {
		return this.importsForUtilityClasses;
	}

	/**
	 * All directives that have been defined in the GraphQL schema for this type
	 */
	
	
	public List<AppliedDirective> getAppliedDirectives() {
		return this.appliedDirectives;
	}

	/**
	 * List of additional interfaces implemented by this object. Items can be added to this list through the schema
	 * personalization capability.<br/>
	 * Interface can be added to types, input types, interfaces, unions and enums.
	 */
	
	
	public Set<String> getAdditionalInterfaces() {
		return this.additionalInterfaces;
	}

	/**
	 * The comments that have been found before this type, in the provided GraphQL schema
	 */
	
	
	public List<String> getComments() {
		return this.comments;
	}

	/**
	 * The description of this type, in the provided GraphQL schema
	 */
	
	
	public Description getDescription() {
		return this.description;
	}

	/**
	 * The name of the object type
	 */
	
	
	public void setName(final String name) {
		this.name = name;
	}

	/**
	 * The list of imports for this object. It's an order Set, so that the generated java file is clean
	 */
	
	
	public void setImports(final Set<String> imports) {
		this.imports = imports;
	}

	/**
	 * The list of imports for this object, that should be used for utility classes, when
	 * {@link GraphQLConfiguration#isSeparateUtilityClasses()} is true. It's an order Set, so that the generated java
	 * file is clean
	 */
	
	
	public void setImportsForUtilityClasses(final Set<String> importsForUtilityClasses) {
		this.importsForUtilityClasses = importsForUtilityClasses;
	}

	/**
	 * All directives that have been defined in the GraphQL schema for this type
	 */
	
	
	public void setAppliedDirectives(final List<AppliedDirective> appliedDirectives) {
		this.appliedDirectives = appliedDirectives;
	}

	/**
	 * List of additional interfaces implemented by this object. Items can be added to this list through the schema
	 * personalization capability.<br/>
	 * Interface can be added to types, input types, interfaces, unions and enums.
	 */
	
	
	public void setAdditionalInterfaces(final Set<String> additionalInterfaces) {
		this.additionalInterfaces = additionalInterfaces;
	}

	/**
	 * The description of this type, in the provided GraphQL schema
	 */
	
	
	public void setDescription(final Description description) {
		this.description = description;
	}

	@java.lang.Override
	
	
	public boolean equals(final java.lang.Object o) {
		if (o == this) return true;
		if (!(o instanceof AbstractType)) return false;
		final AbstractType other = (AbstractType) o;
		if (!other.canEqual((java.lang.Object) this)) return false;
		final java.lang.Object this$configuration = this.getConfiguration();
		final java.lang.Object other$configuration = other.getConfiguration();
		if (this$configuration == null ? other$configuration != null : !this$configuration.equals(other$configuration)) return false;
		final java.lang.Object this$documentParser = this.getDocumentParser();
		final java.lang.Object other$documentParser = other.getDocumentParser();
		if (this$documentParser == null ? other$documentParser != null : !this$documentParser.equals(other$documentParser)) return false;
		final java.lang.Object this$name = this.getName();
		final java.lang.Object other$name = other.getName();
		if (this$name == null ? other$name != null : !this$name.equals(other$name)) return false;
		final java.lang.Object this$imports = this.getImports();
		final java.lang.Object other$imports = other.getImports();
		if (this$imports == null ? other$imports != null : !this$imports.equals(other$imports)) return false;
		final java.lang.Object this$importsForUtilityClasses = this.getImportsForUtilityClasses();
		final java.lang.Object other$importsForUtilityClasses = other.getImportsForUtilityClasses();
		if (this$importsForUtilityClasses == null ? other$importsForUtilityClasses != null : !this$importsForUtilityClasses.equals(other$importsForUtilityClasses)) return false;
		final java.lang.Object this$annotation = this.getAnnotation();
		final java.lang.Object other$annotation = other.getAnnotation();
		if (this$annotation == null ? other$annotation != null : !this$annotation.equals(other$annotation)) return false;
		final java.lang.Object this$appliedDirectives = this.getAppliedDirectives();
		final java.lang.Object other$appliedDirectives = other.getAppliedDirectives();
		if (this$appliedDirectives == null ? other$appliedDirectives != null : !this$appliedDirectives.equals(other$appliedDirectives)) return false;
		final java.lang.Object this$additionalInterfaces = this.getAdditionalInterfaces();
		final java.lang.Object other$additionalInterfaces = other.getAdditionalInterfaces();
		if (this$additionalInterfaces == null ? other$additionalInterfaces != null : !this$additionalInterfaces.equals(other$additionalInterfaces)) return false;
		final java.lang.Object this$comments = this.getComments();
		final java.lang.Object other$comments = other.getComments();
		if (this$comments == null ? other$comments != null : !this$comments.equals(other$comments)) return false;
		final java.lang.Object this$description = this.getDescription();
		final java.lang.Object other$description = other.getDescription();
		if (this$description == null ? other$description != null : !this$description.equals(other$description)) return false;
		final java.lang.Object this$graphQlType = this.getGraphQlType();
		final java.lang.Object other$graphQlType = other.getGraphQlType();
		if (this$graphQlType == null ? other$graphQlType != null : !this$graphQlType.equals(other$graphQlType)) return false;
		return true;
	}

	
	
	protected boolean canEqual(final java.lang.Object other) {
		return other instanceof AbstractType;
	}

	@java.lang.Override
	
	
	public int hashCode() {
		final int PRIME = 59;
		int result = 1;
		final java.lang.Object $configuration = this.getConfiguration();
		result = result * PRIME + ($configuration == null ? 43 : $configuration.hashCode());
		final java.lang.Object $documentParser = this.getDocumentParser();
		result = result * PRIME + ($documentParser == null ? 43 : $documentParser.hashCode());
		final java.lang.Object $name = this.getName();
		result = result * PRIME + ($name == null ? 43 : $name.hashCode());
		final java.lang.Object $imports = this.getImports();
		result = result * PRIME + ($imports == null ? 43 : $imports.hashCode());
		final java.lang.Object $importsForUtilityClasses = this.getImportsForUtilityClasses();
		result = result * PRIME + ($importsForUtilityClasses == null ? 43 : $importsForUtilityClasses.hashCode());
		final java.lang.Object $annotation = this.getAnnotation();
		result = result * PRIME + ($annotation == null ? 43 : $annotation.hashCode());
		final java.lang.Object $appliedDirectives = this.getAppliedDirectives();
		result = result * PRIME + ($appliedDirectives == null ? 43 : $appliedDirectives.hashCode());
		final java.lang.Object $additionalInterfaces = this.getAdditionalInterfaces();
		result = result * PRIME + ($additionalInterfaces == null ? 43 : $additionalInterfaces.hashCode());
		final java.lang.Object $comments = this.getComments();
		result = result * PRIME + ($comments == null ? 43 : $comments.hashCode());
		final java.lang.Object $description = this.getDescription();
		result = result * PRIME + ($description == null ? 43 : $description.hashCode());
		final java.lang.Object $graphQlType = this.getGraphQlType();
		result = result * PRIME + ($graphQlType == null ? 43 : $graphQlType.hashCode());
		return result;
	}
}
