/**
 * 
 */
package com.graphql_java_generator.client.request;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;

import com.graphql_java_generator.annotation.GraphQLScalar;
import com.graphql_java_generator.annotation.RequestType;
import com.graphql_java_generator.client.GraphQLConfiguration;
import com.graphql_java_generator.exception.GraphQLRequestExecutionException;
import com.graphql_java_generator.exception.GraphQLRequestPreparationException;

/**
 * This class contains the description for a GraphQL request that will be sent to the server. It's an abstract class,
 * and can not be use directly: a concrete class is generated by the plugin, when in client mode. This concrete class
 * provides all the necessary context to this abstract class for it to work properly.<BR/>
 * This class stores:
 * <UL>
 * <LI>The query part, if any</LI>
 * <LI>The mutation part, if any</LI>
 * <LI>The subscription part, if any</LI>
 * <LI>The fragments, if any</LI>
 * </UL>
 * 
 * @author etienne-sf
 */
public abstract class AbstractGraphQLRequest {

	/**
	 * This contains the default configuration, that will apply if no local configuration has been defined for this
	 * instance
	 */
	static GraphQLConfiguration staticConfiguration = null;

	/**
	 * This contains the configuration for this instance. This configuration overrides the {@link #staticConfiguration},
	 * if defined.
	 */
	GraphQLConfiguration instanceConfiguration = null;

	/** The query, if any */
	QueryField query = null;

	/** The mutation, if any */
	QueryField mutation = null;

	/** The mutation, if any */
	QueryField subscription = null;

	/** All the fragments defined for this query */
	List<Fragment> fragments = new ArrayList<>();

	/** The string that has been used to create this GraphQL request */
	final String graphQLRequest;

	/**
	 * Null if the request is a full request. Mandatory if the request is a partial request. When this GraphQLRequest is
	 * built for a partial query, that is for a particular query/mutation/subscription, then fieldName states whether
	 * this queryName is actually a query, a mutation or a subscription.
	 */
	final RequestType requestType;
	/**
	 * Null if the request is a full request. Mandatory if the request is a partial request.<BR/>
	 * When this GraphQLRequest is built for a partial query, that is for a particular query/mutation/subscription, then
	 * queryName is the name of the query, mutation or subscription. This allow to check that the GraphQLRequest is the
	 * good to be executed for this partial query.
	 */
	final String queryName;

	/**
	 * Create the instance, from the GraphQL request, for a partial request.<BR/>
	 * 
	 * <B><U>Important note:</U></B> this constructor <B>SHOULD NOT</B> be called by external application. Its signature
	 * may change in the future. To prepare Partial Requests, application code <B>SHOULD</B> call the
	 * getXxxxGraphQLRequests methods, that are generated in the query/mutation/subscription java classes.
	 * 
	 * @param graphQLRequest
	 *            The <B>partial</B> GraphQL request, in text format. Writing partial request allows use to execute a
	 *            query/mutation/subscription, and only define what's expected as a response for this
	 *            query/mutation/subscription. You can send the parameters for this query/mutation/subscription as
	 *            parameter of the java method, without dealing with bind variable in the GraphQL query. Please read the
	 *            <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">client doc
	 *            page</A> for more information, including hints and limitations.
	 * @param requestType
	 *            The information whether this queryName is actually a query, a mutation or a subscription
	 * @param queryName
	 *            The name of the query, mutation or subscription
	 * @param The
	 *            list of input parameters for this query/mutation/subscription
	 * @throws GraphQLRequestPreparationException
	 */
	public AbstractGraphQLRequest(String graphQLRequest, RequestType requestType, String queryName,
			InputParameter... inputParams) throws GraphQLRequestPreparationException {
		if (requestType == null) {
			throw new NullPointerException("requestType is mandatory, but a null value has been provided");
		}
		if (queryName == null) {
			throw new NullPointerException("queryName is mandatory, but a null value has been provided");
		}
		this.requestType = requestType;
		this.queryName = queryName;
		this.graphQLRequest = graphQLRequest;

		QueryField field;
		switch (requestType) {
		case query:
			query = getQueryContext();// Get the query field from the concrete class
			field = new QueryField(query.clazz, queryName);
			query.fields.add(field);
			break;
		case mutation:
			mutation = getMutationContext();// Get the mutation field from the concrete class
			field = new QueryField(mutation.clazz, queryName);
			mutation.fields.add(field);
			break;
		case subscription:
			subscription = getSubscriptionContext();// Get the subscription field from the concrete class
			field = new QueryField(subscription.clazz, queryName);
			subscription.fields.add(field);
			break;
		default:
			throw new GraphQLRequestPreparationException("Non managed request type '" + requestType
					+ " while reading the GraphQL request: " + graphQLRequest);
		}

		// Let's add the input parameters to this new field
		field.inputParameters = Arrays.asList(inputParams);

		// Ok, we have to parse a string which looks like that: "query {human(id: &humanId) { id name friends{name}}}"
		// We tokenize the string, by using the space as a delimiter, and all other special GraphQL characters
		QueryTokenizer qt = new QueryTokenizer(this.graphQLRequest);

		// The graphQLRequest may be null (for instance for a scalar, or if we want the plugin to automatically add all
		// scalar fields for this query/mutation/subscription)
		if (!qt.hasMoreTokens()) {
			// Ok, we're done
		} else {
			// The first token must be a {
			// And we must read it first, before parsing the request content
			String token = qt.nextToken();
			if (!"{".equals(token)) {
				throw new GraphQLRequestPreparationException(
						"The Partial GraphQL Request should start by a '{', but it doesn't: " + graphQLRequest);
			}
			field.readTokenizerForResponseDefinition(qt);
		}

		// For each non scalar field, we add its non scalar fields, if none was defined
		AddScalarFieldToEmptyNonScalarField();
		// Let's add the <I>__typename</I> fields to all non scalar types
		addTypenameFields();
	}

	/**
	 * Creates the GraphQL request, for a full request. It will:
	 * <UL>
	 * <LI>Read the query and/or the mutation</LI>
	 * <LI>Read all fragment definitions</LI>
	 * <LI>For all non scalar field, subfields (and so on recursively), if they are empty (that is the query doesn't
	 * define the requested fields of a non scalar field, then all its scalar fields are added)</LI>
	 * <LI>Add the introspection __typename field to all scalar field list, if it doesnt't already exist. This is
	 * necessary to allow proper deserialization of interfaces and unions.</LI>
	 * </UL>
	 * 
	 * @param graphQLRequest
	 *            The GraphQL request, in text format, as defined in the GraphQL specifications, and as it can be used
	 *            in GraphiQL. Please read the
	 *            <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">client doc
	 *            page</A> for more information, including hints and limitations.
	 * 
	 * @throws GraphQLRequestPreparationException
	 */
	public AbstractGraphQLRequest(String graphQLRequest) throws GraphQLRequestPreparationException {
		this.requestType = null;
		this.queryName = null;
		this.graphQLRequest = graphQLRequest;

		// Ok, we have to parse a string which looks like that: "query {human(id: &humanId) { id name friends{name}}}"
		// We tokenize the string, by using the space as a delimiter, and all other special GraphQL characters
		QueryTokenizer qt = new QueryTokenizer(this.graphQLRequest);
		RequestType requestType = RequestType.query; // If not precised, then it's a query

		// We scan the input string. It may contain fragment definition and query/mutation/subscription
		while (qt.hasMoreTokens()) {
			String token = qt.nextToken();

			switch (token) {
			case "fragment":
				fragments.add(new Fragment(qt, this.getClass().getPackage().getName()));
				break;
			case "query":
			case "mutation":
			case "subscription":
				requestType = RequestType.valueOf(token);
				break;
			case "{":
				// We read the query/mutation/subscription like any field.
				switch (requestType) {
				case query:
					query = getQueryContext();// Get the query field from the concrete class
					query.readTokenizerForResponseDefinition(qt);
					break;
				case mutation:
					mutation = getMutationContext();// Get the mutation field from the concrete class
					mutation.readTokenizerForResponseDefinition(qt);
					break;
				case subscription:
					subscription = getSubscriptionContext();// Get the subscription field from the concrete class
					subscription.readTokenizerForResponseDefinition(qt);
					break;
				default:
					throw new GraphQLRequestPreparationException("Non managed request type '" + requestType
							+ " while reading the GraphQL request: " + graphQLRequest);
				}
				break;
			default:
				throw new GraphQLRequestPreparationException(
						"Unknown token '" + token + " while reading the GraphQL request: " + graphQLRequest);
			}
		}

		if (query == null && mutation == null) {
			throw new GraphQLRequestPreparationException("No response definition found");
		}

		// For each non scalar field, we add its non scalar fields, if none was defined
		AddScalarFieldToEmptyNonScalarField();
		// Let's add the <I>__typename</I> fields to all non scalar types
		addTypenameFields();
	}

	public <T> T exec(Class<T> t, Map<String, Object> params) throws GraphQLRequestExecutionException {
		String request = buildRequest(params);

		if (instanceConfiguration != null) {
			return instanceConfiguration.getQueryExecutor().execute(request, t);
		} else if (staticConfiguration != null) {
			return staticConfiguration.getQueryExecutor().execute(request, t);
		} else {
			throw new GraphQLRequestExecutionException(
					"The GraphQLRequestConfiguration has not been set in the GraphQLRequest. "
							+ "Please set either the GraphQL instance configuration "
							+ "or the GraphQL static configuration before executing a GraphQL request");
		}
	}

	/**
	 * Adds the <I>__typename</I> fields to all non scalar types
	 * 
	 * @param graphQLRequest
	 * @throws GraphQLRequestPreparationException
	 */
	private void addTypenameFields() throws GraphQLRequestPreparationException {

		// We need the __typename fields, to properly parse the JSON response for interfaces and unions.
		// So we add it for every returned object.
		if (query != null) {
			query.addTypenameFields();
		}
		if (mutation != null) {
			mutation.addTypenameFields();
		}
		if (subscription != null) {
			subscription.addTypenameFields();
		}

		for (Fragment f : fragments) {
			f.addTypenameFields();
		}
	}

	/**
	 * For each non scalar fields of the query (if defined), the mutation (if defined) and the subscription (if
	 * defined), we add its non scalar fields, if none was defined.
	 * 
	 * @throws GraphQLRequestPreparationException
	 */
	private void AddScalarFieldToEmptyNonScalarField() throws GraphQLRequestPreparationException {
		AddScalarFieldToEmptyNonScalarField(query);
		AddScalarFieldToEmptyNonScalarField(mutation);
		AddScalarFieldToEmptyNonScalarField(subscription);
	}

	private void AddScalarFieldToEmptyNonScalarField(QueryField field) throws GraphQLRequestPreparationException {
		// If this field contains no subfield, and is not a scalar, we add all its scalar fields, as requested fields.
		if (field == null || field.isScalar()) {
			// No action
		} else if (field.fields.size() == 0) {
			// This non scalar field has no subfields in the GraphQL request
			// We'll request all it scalar fields.

			if (field.clazz.isInterface()) {
				// For interfaces, we look for getters
				for (Method m : field.clazz.getDeclaredMethods()) {
					if (m.getName().startsWith("get")) {
						GraphQLScalar graphQLScalar = m.getAnnotation(GraphQLScalar.class);
						if (graphQLScalar != null) {
							// We've found a subfield that is a scalar. Let's add it.
							field.fields.add(new QueryField(field.clazz, graphQLScalar.fieldName()));
						}
					}
				}
			} else {
				// For objects, we look for class's attributes
				for (Field f : field.clazz.getDeclaredFields()) {
					GraphQLScalar graphQLScalar = f.getAnnotation(GraphQLScalar.class);
					if (graphQLScalar != null) {
						// We've found a subfield that is a scalar. Let's add it.
						field.fields.add(new QueryField(field.clazz, graphQLScalar.fieldName()));
					}
				}
			}
		} else {
			// This non scalar fields contains requested subfield. We recurse into each of its fields.
			for (QueryField f : field.fields)
				AddScalarFieldToEmptyNonScalarField(f);
		} // for
	}

	/**
	 * 
	 * @param params
	 * @return
	 * @throws GraphQLRequestExecutionException
	 */
	public String buildRequest(Map<String, Object> params) throws GraphQLRequestExecutionException {
		StringBuilder sb = new StringBuilder("{\"query\":\"");

		// Let's start by the fragments
		for (Fragment fragment : fragments) {
			fragment.appendToGraphQLRequests(sb, params);
		}

		// Then the other parts of the request
		if (query != null) {
			query.appendToGraphQLRequests(sb, params, true);
		}
		if (mutation != null) {
			mutation.appendToGraphQLRequests(sb, params, true);
		}
		if (subscription != null) {
			subscription.appendToGraphQLRequests(sb, params, true);
		}

		sb.append("\",\"variables\":null,\"operationName\":null}");

		return sb.toString();
	}

	/**
	 * Retrieved the {@link QueryField} for the query (that is the query type coming from the GraphQL schema) from the
	 * concrete class.
	 * 
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	protected abstract QueryField getQueryContext() throws GraphQLRequestPreparationException;

	/**
	 * Retrieved the {@link QueryField} for the mutation (that is the mutation type coming from the GraphQL schema) from
	 * the concrete class.
	 * 
	 * @return
	 */
	protected abstract QueryField getMutationContext() throws GraphQLRequestPreparationException;

	/**
	 * Retrieved the {@link QueryField} for the subscription (that is the subscription type coming from the GraphQL
	 * schema) from the concrete class.
	 * 
	 * @return
	 */
	protected abstract QueryField getSubscriptionContext() throws GraphQLRequestPreparationException;

	public QueryField getQuery() {
		return query;
	}

	public QueryField getMutation() {
		return mutation;
	}

	public QueryField getSubscription() {
		return subscription;
	}

	public List<Fragment> getFragments() {
		return fragments;
	}

	public RequestType getRequestType() {
		return requestType;
	}

	public String getQueryName() {
		return queryName;
	}

	/**
	 * This gets the default configuration, that will apply if no local configuration has been defined for this
	 * instance.
	 * 
	 * @return the staticConfiguration
	 */
	public static GraphQLConfiguration getStaticConfiguration() {
		return staticConfiguration;
	}

	/**
	 * This sets the default configuration, that will apply if no local configuration has been defined for this
	 * instance.
	 * 
	 * @param staticConfiguration
	 *            the staticConfiguration to set
	 */
	public static void setStaticConfiguration(GraphQLConfiguration staticConfiguration) {
		AbstractGraphQLRequest.staticConfiguration = staticConfiguration;
	}

	/**
	 * This gets the configuration for this instance. This configuration overrides the
	 * {@link #getStaticConfiguration()}, if defined.
	 * 
	 * @return the instanceConfiguration
	 */
	public GraphQLConfiguration getInstanceConfiguration() {
		return instanceConfiguration;
	}

	/**
	 * This sets the configuration for this instance. This configuration overrides the
	 * {@link #getStaticConfiguration()}, if defined.
	 * 
	 * @param instanceConfiguration
	 *            the instanceConfiguration to set
	 */
	public void setInstanceConfiguration(GraphQLConfiguration instanceConfiguration) {
		this.instanceConfiguration = instanceConfiguration;
	}

}
